!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ACK	dhcp.cc	/^        ACK = 5,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
ARP_HH_	arp.hh	/^#define ARP_HH_$/;"	d
BOOTREPLY	dhcp.cc	/^        BOOTREPLY = 2$/;"	m	class:net::dhcp::impl::m_type	file:
BOOTREQUEST	dhcp.cc	/^        BOOTREQUEST = 1,$/;"	m	class:net::dhcp::impl::m_type	file:
BROADCAST_ADDRESS	dhcp.cc	/^        BROADCAST_ADDRESS = 28,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
BYTEORDER_HH_	byteorder.hh	/^#define BYTEORDER_HH_$/;"	d
CLASSLESS_ROUTE	dhcp.cc	/^        CLASSLESS_ROUTE = 121,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
CLIENT	tls.cc	/^            CLIENT = GNUTLS_CLIENT, SERVER = GNUTLS_SERVER,$/;"	m	class:seastar::tls::session::type	file:
CLOSED	tcp.hh	/^        static constexpr tcp_state CLOSED         = tcp_state::CLOSED;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
CLOSED	tcp.hh	/^    CLOSED          = (1 << 0),$/;"	m	class:net::tcp_state
CLOSE_WAIT	tcp.hh	/^        static constexpr tcp_state CLOSE_WAIT     = tcp_state::CLOSE_WAIT;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
CLOSE_WAIT	tcp.hh	/^    CLOSE_WAIT      = (1 << 7),$/;"	m	class:net::tcp_state
CLOSING	tcp.hh	/^        static constexpr tcp_state CLOSING        = tcp_state::CLOSING;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
CLOSING	tcp.hh	/^    CLOSING         = (1 << 8),$/;"	m	class:net::tcp_state
CONST_HH_	const.hh	/^#define CONST_HH_$/;"	d
CRYPTOPP_ENABLE_NAMESPACE_WEAK	tcp.hh	/^#define CRYPTOPP_ENABLE_NAMESPACE_WEAK /;"	d
DECLINE	dhcp.cc	/^        DECLINE = 4,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
DER	tls.hh	/^        DER,$/;"	m	class:seastar::tls::x509_crt_format
DHCP_SERVER	dhcp.cc	/^        DHCP_SERVER = 54,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
DISCOVER	dhcp.cc	/^        DISCOVER = 1,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
DISCOVER	dhcp.cc	/^        DISCOVER,$/;"	m	class:net::dhcp::impl::state	file:
DOMAIN_NAME_SERVERS	dhcp.cc	/^        DOMAIN_NAME_SERVERS = 6,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
DONE	dhcp.cc	/^        DONE,$/;"	m	class:net::dhcp::impl::state	file:
END	dhcp.cc	/^        END = 255$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
ESTABLISHED	tcp.hh	/^        static constexpr tcp_state ESTABLISHED    = tcp_state::ESTABLISHED;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
ESTABLISHED	tcp.hh	/^    ESTABLISHED     = (1 << 4),$/;"	m	class:net::tcp_state
ETHERNET	dhcp.cc	/^        ETHERNET = 1$/;"	m	class:net::dhcp::impl::m_type::htype	file:
ETHERNET_HH_	ethernet.hh	/^#define ETHERNET_HH_$/;"	d
FAIL	dhcp.cc	/^        FAIL,$/;"	m	class:net::dhcp::impl::state	file:
FIN_WAIT_1	tcp.hh	/^        static constexpr tcp_state FIN_WAIT_1     = tcp_state::FIN_WAIT_1;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
FIN_WAIT_1	tcp.hh	/^    FIN_WAIT_1      = (1 << 5),$/;"	m	class:net::tcp_state
FIN_WAIT_2	tcp.hh	/^        static constexpr tcp_state FIN_WAIT_2     = tcp_state::FIN_WAIT_2;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
FIN_WAIT_2	tcp.hh	/^    FIN_WAIT_2      = (1 << 6),$/;"	m	class:net::tcp_state
HIGH	tls.hh	/^            HIGH = 4,$/;"	m	class:seastar::tls::dh_params::level
INFORM	dhcp.cc	/^        INFORM = 8,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
INTERFACE_MTU	dhcp.cc	/^        INTERFACE_MTU = 26,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
INVALID	dhcp.cc	/^        INVALID = 255$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
IP_CHECKSUM_HH_	ip_checksum.hh	/^#define IP_CHECKSUM_HH_$/;"	d
IP_HH_	ip.hh	/^#define IP_HH_$/;"	d
LAST_ACK	tcp.hh	/^        static constexpr tcp_state LAST_ACK       = tcp_state::LAST_ACK;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
LAST_ACK	tcp.hh	/^    LAST_ACK        = (1 << 9),$/;"	m	class:net::tcp_state
LEASEACTIVE	dhcp.cc	/^        LEASEACTIVE = 13,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASEQUERY	dhcp.cc	/^        LEASEQUERY = 10,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASEUNASSIGNED	dhcp.cc	/^        LEASEUNASSIGNED = 11,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASEUNKNOWN	dhcp.cc	/^        LEASEUNKNOWN = 12,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
LEASE_TIME	dhcp.cc	/^        LEASE_TIME = 51,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
LEGACY	tls.hh	/^            LEGACY = 2,$/;"	m	class:seastar::tls::dh_params::level
LISTEN	tcp.hh	/^        static constexpr tcp_state LISTEN         = tcp_state::LISTEN;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
LISTEN	tcp.hh	/^    LISTEN          = (1 << 1),$/;"	m	class:net::tcp_state
MARKER	dpdk.cc	/^typedef void    *MARKER[0];   \/**< generic marker for a point in a structure *\/$/;"	t	file:
MAX_DATAGRAM_SIZE	posix-stack.cc	/^    static constexpr int MAX_DATAGRAM_SIZE = 65507;$/;"	m	class:net::posix_udp_channel	file:
MEDIUM	tls.hh	/^            MEDIUM = 3,$/;"	m	class:seastar::tls::dh_params::level
MESSAGE_TYPE	dhcp.cc	/^        MESSAGE_TYPE = 53,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
NAK	dhcp.cc	/^        NAK = 6,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
NET_API_HH_	api.hh	/^#define NET_API_HH_$/;"	d
NET_DHCP_HH_	dhcp.hh	/^#define NET_DHCP_HH_$/;"	d
NET_HH_	net.hh	/^#define NET_HH_$/;"	d
NET_NATIVE_STACK_IMPL_HH_	native-stack-impl.hh	/^#define NET_NATIVE_STACK_IMPL_HH_$/;"	d
NET_TCP_STACK_HH	tcp-stack.hh	/^#define NET_TCP_STACK_HH$/;"	d
NONE	dhcp.cc	/^        NONE,$/;"	m	class:net::dhcp::impl::state	file:
OFFER	dhcp.cc	/^        OFFER = 2,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
PACKET_HH_	packet.hh	/^#define PACKET_HH_$/;"	d
PACKET_UTIL_HH_	packet-util.hh	/^#define PACKET_UTIL_HH_$/;"	d
PAD	dhcp.cc	/^        PAD = 0,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
PARAMETER_REQUEST_LIST	dhcp.cc	/^        PARAMETER_REQUEST_LIST = 55,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
PEM	tls.hh	/^        PEM,$/;"	m	class:seastar::tls::x509_crt_format
POSIX_STACK_HH_	posix-stack.hh	/^#define POSIX_STACK_HH_$/;"	d
PROXY_HH_	proxy.hh	/^#define PROXY_HH_$/;"	d
REBINDING_TIME	dhcp.cc	/^        REBINDING_TIME = 59,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
RELEASE	dhcp.cc	/^        RELEASE = 7,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
RENEWAL_TIME	dhcp.cc	/^        RENEWAL_TIME = 58,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
REQUEST	dhcp.cc	/^        REQUEST = 3,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
REQUEST	dhcp.cc	/^        REQUEST,$/;"	m	class:net::dhcp::impl::state	file:
REQUESTED_ADDRESS	dhcp.cc	/^        REQUESTED_ADDRESS = 50,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
ROUTER	dhcp.cc	/^        ROUTER = 3,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
SCTP	api.hh	/^    SCTP = IPPROTO_SCTP$/;"	m	class:seastar::transport
SERVER	tls.cc	/^            CLIENT = GNUTLS_CLIENT, SERVER = GNUTLS_SERVER,$/;"	m	class:seastar::tls::session::type	file:
STACK_HH_	native-stack.hh	/^#define STACK_HH_$/;"	d
SUBNET_MASK	dhcp.cc	/^        SUBNET_MASK = 1,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type	file:
SYN_RECEIVED	tcp.hh	/^        static constexpr tcp_state SYN_RECEIVED   = tcp_state::SYN_RECEIVED;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
SYN_RECEIVED	tcp.hh	/^    SYN_RECEIVED    = (1 << 3),$/;"	m	class:net::tcp_state
SYN_SENT	tcp.hh	/^        static constexpr tcp_state SYN_SENT       = tcp_state::SYN_SENT;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
SYN_SENT	tcp.hh	/^    SYN_SENT        = (1 << 2),$/;"	m	class:net::tcp_state
TCP	api.hh	/^    TCP = IPPROTO_TCP,$/;"	m	class:seastar::transport
TCP_HH_	tcp.hh	/^#define TCP_HH_$/;"	d
TIME_WAIT	tcp.hh	/^        static constexpr tcp_state TIME_WAIT      = tcp_state::TIME_WAIT;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
TIME_WAIT	tcp.hh	/^    TIME_WAIT       = (1 << 10)$/;"	m	class:net::tcp_state
TOEPLITZ_HH_	toeplitz.hh	/^#define TOEPLITZ_HH_$/;"	d
UDP_HH_	udp.hh	/^#define UDP_HH_$/;"	d
ULTRA	tls.hh	/^            ULTRA = 5$/;"	m	class:seastar::tls::dh_params::level
VIRTIO_HH_	virtio.hh	/^#define VIRTIO_HH_$/;"	d
VIRTIO_INTERFACE_HH_	virtio-interface.hh	/^#define VIRTIO_INTERFACE_HH_$/;"	d
VIRTIO_NET_F_CSUM	virtio-interface.hh	/^#define VIRTIO_NET_F_CSUM /;"	d
VIRTIO_NET_F_CTRL_GUEST_OFFLOADS	virtio-interface.hh	/^#define VIRTIO_NET_F_CTRL_GUEST_OFFLOADS /;"	d
VIRTIO_NET_F_CTRL_MAC_ADDR	virtio-interface.hh	/^#define VIRTIO_NET_F_CTRL_MAC_ADDR /;"	d
VIRTIO_NET_F_CTRL_RX	virtio-interface.hh	/^#define VIRTIO_NET_F_CTRL_RX /;"	d
VIRTIO_NET_F_CTRL_VLAN	virtio-interface.hh	/^#define VIRTIO_NET_F_CTRL_VLAN /;"	d
VIRTIO_NET_F_CTRL_VQ	virtio-interface.hh	/^#define VIRTIO_NET_F_CTRL_VQ /;"	d
VIRTIO_NET_F_GUEST_ANNOUNCE	virtio-interface.hh	/^#define VIRTIO_NET_F_GUEST_ANNOUNCE /;"	d
VIRTIO_NET_F_GUEST_CSUM	virtio-interface.hh	/^#define VIRTIO_NET_F_GUEST_CSUM /;"	d
VIRTIO_NET_F_GUEST_ECN	virtio-interface.hh	/^#define VIRTIO_NET_F_GUEST_ECN /;"	d
VIRTIO_NET_F_GUEST_TSO4	virtio-interface.hh	/^#define VIRTIO_NET_F_GUEST_TSO4 /;"	d
VIRTIO_NET_F_GUEST_TSO6	virtio-interface.hh	/^#define VIRTIO_NET_F_GUEST_TSO6 /;"	d
VIRTIO_NET_F_GUEST_UFO	virtio-interface.hh	/^#define VIRTIO_NET_F_GUEST_UFO /;"	d
VIRTIO_NET_F_HOST_ECN	virtio-interface.hh	/^#define VIRTIO_NET_F_HOST_ECN /;"	d
VIRTIO_NET_F_HOST_TSO4	virtio-interface.hh	/^#define VIRTIO_NET_F_HOST_TSO4 /;"	d
VIRTIO_NET_F_HOST_TSO6	virtio-interface.hh	/^#define VIRTIO_NET_F_HOST_TSO6 /;"	d
VIRTIO_NET_F_HOST_UFO	virtio-interface.hh	/^#define VIRTIO_NET_F_HOST_UFO /;"	d
VIRTIO_NET_F_MAC	virtio-interface.hh	/^#define VIRTIO_NET_F_MAC /;"	d
VIRTIO_NET_F_MQ	virtio-interface.hh	/^#define VIRTIO_NET_F_MQ /;"	d
VIRTIO_NET_F_MRG_RXBUF	virtio-interface.hh	/^#define VIRTIO_NET_F_MRG_RXBUF /;"	d
VIRTIO_NET_F_STATUS	virtio-interface.hh	/^#define VIRTIO_NET_F_STATUS /;"	d
VIRTIO_RING_F_EVENT_IDX	virtio-interface.hh	/^#define VIRTIO_RING_F_EVENT_IDX /;"	d
VIRTIO_RING_F_INDIRECT_DESC	virtio-interface.hh	/^#define VIRTIO_RING_F_INDIRECT_DESC /;"	d
VRING_AVAIL_F_NO_INTERRUPT	virtio-interface.hh	/^#define VRING_AVAIL_F_NO_INTERRUPT /;"	d
VRING_DESC_F_INDIRECT	virtio-interface.hh	/^#define VRING_DESC_F_INDIRECT /;"	d
VRING_DESC_F_NEXT	virtio-interface.hh	/^#define VRING_DESC_F_NEXT /;"	d
VRING_DESC_F_WRITE	virtio-interface.hh	/^#define VRING_DESC_F_WRITE /;"	d
VRING_USED_F_NO_NOTIFY	virtio-interface.hh	/^#define VRING_USED_F_NO_NOTIFY /;"	d
XENFRONT_HH_	xenfront.hh	/^#define XENFRONT_HH_$/;"	d
_LINUX_VIRTIO_RING_H	virtio-interface.hh	/^#define _LINUX_VIRTIO_RING_H$/;"	d
_PACKET_DATA_SOURCE_HH	packet-data-source.hh	/^#define _PACKET_DATA_SOURCE_HH$/;"	d
_SEASTAR_DPDK_DEV_H	dpdk.hh	/^#define _SEASTAR_DPDK_DEV_H$/;"	d
_address	posix-stack.cc	/^    ipv4_addr _address;$/;"	m	class:net::posix_udp_channel	file:
_all_data_acked_promise	tcp.hh	/^            std::experimental::optional<promise<>> _all_data_acked_promise;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
_allocated_frags	packet.hh	/^        uint16_t _allocated_frags;$/;"	m	struct:net::final::impl
_arp	arp.hh	/^    arp& _arp;$/;"	m	class:net::arp_for_protocol
_arp	ip.hh	/^    arp_for<ipv4> _arp;$/;"	m	class:net::ipv4
_arp_for_protocol	arp.hh	/^    std::unordered_map<uint16_t, arp_for_protocol*> _arp_for_protocol;$/;"	m	class:net::arp
_avail	virtio.cc	/^    avail _avail;$/;"	m	class:virtio::vring	file:
_avail_added_since_kick	virtio.cc	/^        uint16_t _avail_added_since_kick = 0;$/;"	m	struct:virtio::vring::avail	file:
_avail_event	virtio.cc	/^    std::atomic<uint16_t>* _avail_event;$/;"	m	class:virtio::vring	file:
_available	xenfront.hh	/^        semaphore _available = { front_ring::nr_ents };$/;"	m	class:xen::front_ring::entries
_available_descriptors	virtio.cc	/^    semaphore _available_descriptors = { 0 };$/;"	m	class:virtio::vring	file:
_backend	xenfront.cc	/^    std::string _backend;$/;"	m	class:xen::xenfront_qp	file:
_blobs	tls.hh	/^        std::multimap<sstring, boost::any> _blobs;$/;"	m	class:seastar::tls::dh_params::credentials_builder
_buf	native-stack-impl.hh	/^    packet _buf;$/;"	m	class:net::final
_buf	posix-stack.hh	/^    temporary_buffer<char> _buf;$/;"	m	class:net::final
_buf_physaddr	dpdk.cc	/^        phys_addr_t _buf_physaddr;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_buf_size	posix-stack.hh	/^    size_t _buf_size;$/;"	m	class:net::final
_buffer	posix-stack.cc	/^        char* _buffer;$/;"	m	struct:net::posix_udp_channel::recv_ctx	file:
_buffer_chains	virtio.cc	/^    std::unique_ptr<BufferChain[]> _buffer_chains;$/;"	m	class:virtio::vring	file:
_buffers	virtio.cc	/^        std::vector<std::unique_ptr<char[], free_deleter>> _buffers;$/;"	m	class:virtio::qp::rxq	file:
_bufs	dpdk.cc	/^    std::vector<char*> _bufs;$/;"	m	class:dpdk::dpdk_qp	file:
_cert	tls.cc	/^    gnutls_x509_crt_t _cert;$/;"	m	class:seastar::tls::x509_cert::impl	file:
_channels	ip.hh	/^    std::unordered_map<uint16_t, lw_shared_ptr<udp_channel_state>> _channels;$/;"	m	class:net::ipv4_udp
_closed	posix-stack.cc	/^    bool _closed;$/;"	m	class:net::posix_udp_channel	file:
_closed	udp.cc	/^    bool _closed;$/;"	m	class:net::ipv4_udp_impl::native_channel	file:
_cmsg	posix-stack.cc	/^        cmsg_with_pktinfo _cmsg;$/;"	m	struct:net::posix_udp_channel::recv_ctx	file:
_collectd_regs	dpdk.cc	/^    std::vector<scollectd::registration> _collectd_regs;$/;"	m	class:dpdk::dpdk_device	file:
_collectd_regs	ip.hh	/^    scollectd::registrations _collectd_regs;$/;"	m	class:net::ipv4
_collectd_regs	net.hh	/^    scollectd::registrations _collectd_regs;$/;"	m	class:net::qp
_collectd_regs	tcp.hh	/^    scollectd::registrations _collectd_regs;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_complete	virtio.cc	/^    Completion _complete;$/;"	m	class:virtio::vring	file:
_config	native-stack.cc	/^    promise<> _config;$/;"	m	class:net::native_network_stack	file:
_config	virtio.cc	/^    ring_config _config;$/;"	m	class:virtio::vring	file:
_conn	native-stack-impl.hh	/^    lw_shared_ptr<typename Protocol::connection> _conn;$/;"	m	class:net::final
_conn	native-stack-impl.hh	/^    lw_shared_ptr<typename Protocol::connection> _conn;$/;"	m	class:net::native_connected_socket_impl
_conn	native-stack-impl.hh	/^    typename Protocol::connection& _conn;$/;"	m	class:net::final
_conn	tcp.hh	/^        connection* _conn = nullptr;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_connect_done	tcp.hh	/^        promise<> _connect_done;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_cpu	proxy.cc	/^    unsigned _cpu;$/;"	m	class:net::proxy_net_device	file:
_cred	tls.cc	/^    ::shared_ptr<certificate_credentials> _cred;$/;"	m	class:seastar::tls::tls_socket_impl	file:
_creds	tls.cc	/^    ::shared_ptr<certificate_credentials> _creds;$/;"	m	class:seastar::tls::session	file:
_creds	tls.cc	/^    ::shared_ptr<server_credentials> _creds;$/;"	m	class:seastar::tls::server_session	file:
_creds	tls.cc	/^    gnutls_certificate_credentials_t _creds;$/;"	m	class:seastar::tls::certificate_credentials::impl	file:
_csi	api.hh	/^    std::unique_ptr<net::connected_socket_impl> _csi;$/;"	m	class:seastar::connected_socket
_cur_frag	native-stack-impl.hh	/^    size_t _cur_frag = 0;$/;"	m	class:net::final
_cur_frag	packet-data-source.hh	/^    size_t _cur_frag = 0;$/;"	m	class:net::final
_data	packet.hh	/^        char _data[internal_data_size]; \/\/ only _frags[0] may use$/;"	m	struct:net::final::impl
_data_off	dpdk.cc	/^        uint16_t _data_off;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_data_received_promise	tcp.hh	/^            std::experimental::optional<promise<>> _data_received_promise;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
_delayed_ack	tcp.hh	/^        timer<lowres_clock> _delayed_ack;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_deleter	packet.hh	/^        deleter _deleter;$/;"	m	struct:net::final::impl
_descs	virtio.cc	/^    desc* _descs;$/;"	m	class:virtio::vring	file:
_dev	dpdk.cc	/^    dpdk_device* _dev;$/;"	m	class:dpdk::dpdk_qp	file:
_dev	net.hh	/^    std::shared_ptr<device> _dev;$/;"	m	class:net::interface
_dev	proxy.cc	/^    device* _dev;$/;"	m	class:net::proxy_net_device	file:
_dev	virtio.cc	/^        qp& _dev;$/;"	m	class:virtio::qp::rxq	file:
_dev	virtio.cc	/^        qp& _dev;$/;"	m	class:virtio::qp::txq	file:
_dev	virtio.cc	/^    device* _dev;$/;"	m	class:virtio::qp	file:
_dev	xenfront.cc	/^    xenfront_device* _dev;$/;"	m	class:xen::xenfront_qp	file:
_dev	xenfront.hh	/^    xenfront_qp& _dev;$/;"	m	class:xen::front_ring
_dev_info	dpdk.cc	/^    rte_eth_dev_info _dev_info = {};$/;"	m	class:dpdk::dpdk_device	file:
_device_str	xenfront.cc	/^    std::string _device_str;$/;"	m	class:xen::xenfront_device	file:
_dh_params	tls.cc	/^    std::unique_ptr<tls::dh_params::impl> _dh_params;$/;"	m	class:seastar::tls::certificate_credentials::impl	file:
_dhcp	native-stack.cc	/^    bool _dhcp = false;$/;"	m	class:net::native_network_stack	file:
_dst	posix-stack.cc	/^        socket_address _dst;$/;"	m	struct:net::posix_udp_channel::send_ctx	file:
_dst	posix-stack.cc	/^    ipv4_addr _dst;$/;"	m	class:net::posix_datagram	file:
_dst	udp.cc	/^    ipv4_addr _dst;$/;"	m	class:net::ipv4_udp_impl::native_datagram	file:
_e	tcp.hh	/^    std::default_random_engine _e;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_enable_fc	dpdk.cc	/^    bool _enable_fc;$/;"	m	class:dpdk::dpdk_device	file:
_entries	xenfront.hh	/^        std::array<gntref, front_ring<T>::nr_ents> _entries;$/;"	m	class:xen::front_ring::entries
_eof	native-stack-impl.hh	/^    bool _eof = false;$/;"	m	class:net::final
_eof	tls.cc	/^    bool _eof = false;$/;"	m	class:seastar::tls::session	file:
_evtchn	xenfront.cc	/^    evtchn   *_evtchn;$/;"	m	class:xen::xenfront_qp	file:
_fc	dpdk.cc	/^        tx_buf_factory& _fc;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_fd	posix-stack.cc	/^    lw_shared_ptr<pollable_fd> _fd;$/;"	m	class:net::final	file:
_fd	posix-stack.cc	/^    std::unique_ptr<pollable_fd> _fd;$/;"	m	class:net::posix_udp_channel	file:
_fd	posix-stack.hh	/^    pollable_fd& _fd;$/;"	m	class:net::final
_fd	posix-stack.hh	/^    pollable_fd& _fd;$/;"	m	class:net::posix_data_sink_impl
_features	virtio.cc	/^    uint64_t _features;$/;"	m	class:virtio::device	file:
_features	xenfront.cc	/^    std::unordered_map<std::string, int> _features;$/;"	m	class:xen::xenfront_qp	file:
_finish	packet.hh	/^        fragment* _finish;$/;"	m	struct:net::final::pseudo_vector
_flags	virtio.cc	/^        flags _flags;$/;"	m	class:virtio::vring::desc	file:
_flags	virtio.cc	/^        std::atomic<uint16_t> _flags;$/;"	m	struct:virtio::vring::avail_layout	file:
_flags	virtio.cc	/^        std::atomic<uint16_t> _flags;$/;"	m	struct:virtio::vring::used_layout	file:
_foreign_ip	tcp.hh	/^        ipaddr _foreign_ip;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_foreign_port	tcp.hh	/^        uint16_t _foreign_port;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_frag_high_thresh	ip.cc	/^constexpr uint32_t ipv4::_frag_high_thresh;$/;"	m	class:net::ipv4	file:
_frag_low_thresh	ip.cc	/^constexpr uint32_t ipv4::_frag_low_thresh;$/;"	m	class:net::ipv4	file:
_frag_timeout	ip.cc	/^constexpr std::chrono::seconds ipv4::_frag_timeout;$/;"	m	class:net::ipv4	file:
_frag_timer	ip.hh	/^    timer<lowres_clock> _frag_timer;$/;"	m	class:net::ipv4
_fragments	virtio.cc	/^        std::vector<fragment> _fragments;$/;"	m	class:virtio::qp::rxq	file:
_frags	dpdk.cc	/^    std::vector<fragment> _frags;$/;"	m	class:dpdk::dpdk_qp	file:
_frags	ip.hh	/^    std::unordered_map<ipv4_frag_id, frag, ipv4_frag_id::hash> _frags;$/;"	m	class:net::ipv4
_frags	packet.hh	/^        fragment _frags[];$/;"	m	struct:net::final::impl
_frags_age	ip.hh	/^    std::list<ipv4_frag_id> _frags_age;$/;"	m	class:net::ipv4
_free_head	virtio.cc	/^    int _free_head = -1;$/;"	m	class:virtio::vring	file:
_free_last	virtio.cc	/^    int _free_last = -1;$/;"	m	class:virtio::vring	file:
_global_arp	ip.hh	/^    arp _global_arp;$/;"	m	class:net::ipv4
_gntalloc	xenfront.cc	/^    gntalloc *_gntalloc;$/;"	m	class:xen::xenfront_qp	file:
_gw_address	ip.hh	/^    ipv4_address _gw_address;$/;"	m	class:net::ipv4
_hdr	posix-stack.cc	/^        struct msghdr _hdr;$/;"	m	struct:net::posix_udp_channel::recv_ctx	typeref:struct:net::posix_udp_channel::recv_ctx::msghdr	file:
_hdr	posix-stack.cc	/^        struct msghdr _hdr;$/;"	m	struct:net::posix_udp_channel::send_ctx	typeref:struct:net::posix_udp_channel::send_ctx::msghdr	file:
_head	virtio.cc	/^        uint16_t _head = 0;$/;"	m	struct:virtio::vring::avail	file:
_header_len	virtio.cc	/^    size_t _header_len;$/;"	m	class:virtio::qp	file:
_headroom	packet.hh	/^        unsigned _headroom = internal_data_size; \/\/ in _data$/;"	m	struct:net::final::impl
_home_cpu	dpdk.cc	/^    unsigned _home_cpu;$/;"	m	class:dpdk::dpdk_device	file:
_host_address	ip.hh	/^    ipv4_address _host_address;$/;"	m	class:net::ipv4
_hostname	tls.cc	/^    const sstring _hostname;$/;"	m	class:seastar::tls::session	file:
_hw_address	net.hh	/^    ethernet_address _hw_address;$/;"	m	class:net::interface
_hw_address	xenfront.cc	/^    ethernet_address _hw_address;$/;"	m	class:xen::xenfront_device	file:
_hw_features	dpdk.cc	/^    net::hw_features _hw_features;$/;"	m	class:dpdk::dpdk_device	file:
_hw_features	net.hh	/^    net::hw_features _hw_features;$/;"	m	class:net::interface
_hw_features	virtio.cc	/^    net::hw_features _hw_features;$/;"	m	class:virtio::device	file:
_hw_features	xenfront.cc	/^    net::hw_features _hw_features;$/;"	m	class:xen::xenfront_device	file:
_icmp	ip.hh	/^    icmp _icmp;$/;"	m	class:net::final
_icmp	ip.hh	/^    ipv4_icmp _icmp;$/;"	m	class:net::ipv4
_id	virtio.cc	/^        uint32_t _id;$/;"	m	struct:virtio::vring::used_elem	file:
_ids	xenfront.hh	/^        std::queue<unsigned, circular_buffer<unsigned>> _ids;$/;"	m	class:xen::front_ring::entries
_idx	virtio.cc	/^        std::atomic<uint16_t> _idx;$/;"	m	struct:virtio::vring::avail_layout	file:
_idx	virtio.cc	/^        std::atomic<uint16_t> _idx;$/;"	m	struct:virtio::vring::used_layout	file:
_impl	api.hh	/^    std::unique_ptr<udp_channel_impl> _impl;$/;"	m	class:seastar::net::udp_channel
_impl	api.hh	/^    std::unique_ptr<udp_datagram_impl> _impl;$/;"	m	class:seastar::net::final
_impl	dhcp.hh	/^    std::unique_ptr<impl> _impl;$/;"	m	class:net::dhcp
_impl	packet.hh	/^    std::unique_ptr<impl> _impl;$/;"	m	class:net::final
_impl	tls.hh	/^        ::shared_ptr<impl> _impl;$/;"	m	class:seastar::tls::dh_params::x509_cert
_impl	tls.hh	/^        std::unique_ptr<impl> _impl;$/;"	m	class:seastar::tls::dh_params::certificate_credentials
_impl	tls.hh	/^        std::unique_ptr<impl> _impl;$/;"	m	class:seastar::tls::dh_params::level
_in	tls.cc	/^    data_source _in;$/;"	m	class:seastar::tls::session	file:
_in_progress	arp.hh	/^    std::unordered_map<l3addr, resolution> _in_progress;$/;"	m	class:net::arp_for
_inet	ip.hh	/^    inet_type& _inet;$/;"	m	class:net::icmp
_inet	ip.hh	/^    ipv4 &_inet;$/;"	m	class:net::ipv4_udp
_inet	ip.hh	/^    ipv4& _inet;$/;"	m	class:net::ipv4_l4
_inet	native-stack.cc	/^    ipv4 _inet;$/;"	m	class:net::native_network_stack	file:
_inet	tcp.hh	/^    inet_type& _inet;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_inet_l4	ip.hh	/^    ipv4_l4<ip_protocol_num::icmp> _inet_l4;$/;"	m	class:net::final
_inet_l4	ip.hh	/^    ipv4_l4<ip_protocol_num::tcp> _inet_l4;$/;"	m	class:net::final
_input	tls.cc	/^    buf_type _input;$/;"	m	class:seastar::tls::session	file:
_iov	posix-stack.cc	/^        struct iovec _iov;$/;"	m	struct:net::posix_udp_channel::recv_ctx	typeref:struct:net::posix_udp_channel::recv_ctx::iovec	file:
_iovecs	posix-stack.cc	/^        std::vector<struct iovec> _iovecs;$/;"	m	struct:net::posix_udp_channel::send_ctx	file:
_is_i40e_device	dpdk.cc	/^    bool _is_i40e_device = false;$/;"	m	class:dpdk::dpdk_device	file:
_is_vmxnet3_device	dpdk.cc	/^    bool _is_vmxnet3_device = false;$/;"	m	class:dpdk::dpdk_device	file:
_is_zc	dpdk.cc	/^        bool _is_zc = false;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_isn_secret	tcp.hh	/^        static isn_secret _isn_secret;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_isn_secret	tcp.hh	/^typename tcp<InetTraits>::tcb::isn_secret tcp<InetTraits>::tcb::_isn_secret;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_kick	virtio.cc	/^    writeable_eventfd _kick;$/;"	m	class:virtio::notifier_vhost	file:
_l3	ip.hh	/^    l3_protocol _l3;$/;"	m	class:net::ipv4
_l3self	arp.hh	/^    l3addr _l3self = L3::broadcast_address();$/;"	m	class:net::arp_for
_l4	ip.hh	/^    array_map<ip_protocol*, 256> _l4;$/;"	m	class:net::ipv4
_len	packet.hh	/^        unsigned _len = 0;$/;"	m	struct:net::final::impl
_len	virtio.cc	/^        uint32_t _len;$/;"	m	class:virtio::vring::desc	file:
_len	virtio.cc	/^        uint32_t _len;$/;"	m	struct:virtio::vring::used_elem	file:
_lfd	posix-stack.hh	/^    pollable_fd _lfd;$/;"	m	class:net::posix_reuseport_server_socket_impl
_lfd	posix-stack.hh	/^    pollable_fd _lfd;$/;"	m	class:net::posix_server_socket_impl
_link_ready_promise	dpdk.cc	/^    promise<> _link_ready_promise;$/;"	m	class:dpdk::dpdk_device	file:
_listener	native-stack-impl.hh	/^    typename Protocol::listener _listener;$/;"	m	class:net::native_server_socket_impl
_listening	tcp.hh	/^    std::unordered_map<uint16_t, listener*> _listening;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_load_system_trust	tls.cc	/^    bool _load_system_trust = false;$/;"	m	class:seastar::tls::certificate_credentials::impl	file:
_local_ip	tcp.hh	/^        ipaddr _local_ip;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_local_mss	tcp.hh	/^    uint16_t _local_mss;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_local_port	tcp.hh	/^        uint16_t _local_port;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_local_win_scale	tcp.hh	/^    uint8_t _local_win_scale = 0;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_mac	virtio.cc	/^    ethernet_address _mac;$/;"	m	class:virtio::qp_osv	file:
_max_nr_retransmit	tcp.hh	/^constexpr uint16_t tcp<InetTraits>::tcb::_max_nr_retransmit;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_mbuf	dpdk.cc	/^        struct rte_mbuf _mbuf;$/;"	m	class:dpdk::dpdk_qp::tx_buf	typeref:struct:dpdk::dpdk_qp::tx_buf::rte_mbuf	file:
_moving	proxy.cc	/^    std::vector<packet> _moving;$/;"	m	class:net::proxy_net_device	file:
_mss_received	tcp.hh	/^    bool _mss_received = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_name	tls.cc	/^    sstring _name;$/;"	m	class:seastar::tls::tls_socket_impl	file:
_netif	arp.hh	/^    interface* _netif;$/;"	m	class:net::arp
_netif	ip.hh	/^    interface* _netif;$/;"	m	class:net::ipv4
_netif	native-stack.cc	/^    interface _netif;$/;"	m	class:net::native_network_stack	file:
_netif	net.hh	/^    interface* _netif;$/;"	m	class:net::l3_protocol
_netmask	ip.hh	/^    ipv4_address _netmask;$/;"	m	class:net::ipv4
_next	virtio.cc	/^        uint16_t _next;$/;"	m	class:virtio::vring::desc	file:
_next_anonymous_port	ip.hh	/^    uint16_t _next_anonymous_port = min_anonymous_port;$/;"	m	class:net::ipv4_udp
_next_idx	xenfront.hh	/^        std::atomic<uint32_t> _next_idx = { 0 };$/;"	m	class:xen::front_ring::entries
_notifier	virtio.cc	/^    std::unique_ptr<notifier> _notifier;$/;"	m	class:virtio::vring	file:
_nr_frags	packet.hh	/^        uint16_t _nr_frags = 0;$/;"	m	struct:net::final::impl
_nr_full_seg_received	tcp.hh	/^        uint16_t _nr_full_seg_received = 0;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_num_queues	dpdk.cc	/^    uint16_t _num_queues;$/;"	m	class:dpdk::dpdk_device	file:
_num_rx_free_segs	dpdk.cc	/^    size_t _num_rx_free_segs = 0;$/;"	m	class:dpdk::dpdk_qp	file:
_offload_info	packet.hh	/^        offload_info _offload_info;$/;"	m	struct:net::final::impl
_option	tcp.hh	/^        tcp_option _option;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_opts	virtio.cc	/^    boost::program_options::variables_map _opts;$/;"	m	class:virtio::device	file:
_otherend	xenfront.cc	/^    unsigned _otherend;$/;"	m	class:xen::xenfront_qp	file:
_out	tls.cc	/^    data_sink _out;$/;"	m	class:seastar::tls::session	file:
_out_expect	tls.cc	/^    size_t _out_expect = 0;$/;"	m	class:seastar::tls::session	file:
_output_exception	tls.cc	/^    std::exception_ptr _output_exception;$/;"	m	class:seastar::tls::session	file:
_output_pending	tls.cc	/^    std::experimental::optional<future<>> _output_pending;$/;"	m	class:seastar::tls::session	file:
_p	dpdk.cc	/^        std::experimental::optional<packet> _p;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
_p	packet-data-source.hh	/^    packet _p;$/;"	m	class:net::final
_p	posix-stack.cc	/^        packet _p;$/;"	m	struct:net::posix_udp_channel::send_ctx	file:
_p	posix-stack.cc	/^    packet _p;$/;"	m	class:net::posix_datagram	file:
_p	posix-stack.hh	/^    packet _p;$/;"	m	class:net::posix_data_sink_impl
_p	udp.cc	/^    packet _p;$/;"	m	class:net::ipv4_udp_impl::native_datagram	file:
_packet_filter	ip.hh	/^    ip_packet_filter * _packet_filter = nullptr;$/;"	m	class:net::ipv4
_packetq	arp.hh	/^    circular_buffer<l3_protocol::l3packet> _packetq;$/;"	m	class:net::arp
_packetq	ip.hh	/^    circular_buffer<ipv4_traits::l4packet> _packetq;$/;"	m	class:net::icmp
_packetq	ip.hh	/^    circular_buffer<ipv4_traits::l4packet> _packetq;$/;"	m	class:net::ipv4_udp
_packetq	ip.hh	/^    circular_buffer<l3_protocol::l3packet> _packetq;$/;"	m	class:net::ipv4
_packetq	tcp.hh	/^        circular_buffer<typename InetTraits::l4packet> _packetq;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_packetq	tcp.hh	/^    circular_buffer<ipv4_traits::l4packet> _packetq;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_packets	virtio.cc	/^        std::vector<packet_as_buffer_chain> _packets;$/;"	m	class:virtio::qp::txq	file:
_paddr	virtio.cc	/^        phys _paddr;$/;"	m	class:virtio::vring::desc	file:
_params	tls.cc	/^    gnutls_dh_params_t _params;$/;"	m	class:seastar::tls::dh_params::impl	file:
_pending	tcp.hh	/^        size_t _pending = 0;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::listener
_persist	tcp.hh	/^        timer<lowres_clock> _persist;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_pkt_provider_idx	ip.hh	/^    unsigned _pkt_provider_idx = 0;$/;"	m	class:net::ipv4
_pkt_providers	ip.hh	/^    std::vector<ipv4_traits::packet_provider_type> _pkt_providers;$/;"	m	class:net::ipv4
_pkt_providers	net.hh	/^    std::vector<l3_protocol::packet_provider_type> _pkt_providers;$/;"	m	class:net::interface
_pktmbuf_pool_rx	dpdk.cc	/^    rte_mempool *_pktmbuf_pool_rx;$/;"	m	class:dpdk::dpdk_qp	file:
_poll_active	tcp.hh	/^        bool _poll_active = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_poll_tcbs	tcp.hh	/^    circular_buffer<std::pair<lw_shared_ptr<tcb>, ethernet_address>> _poll_tcbs;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_poller	virtio.cc	/^    reactor::poller _poller;$/;"	m	class:virtio::vring	file:
_pool	dpdk.cc	/^        rte_mempool* _pool = nullptr;$/;"	m	class:dpdk::dpdk_qp::tx_buf_factory	file:
_port	ip.hh	/^        uint16_t _port;$/;"	m	class:net::ipv4_udp::registration
_port	tcp.hh	/^        uint16_t _port;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::listener
_port_idx	dpdk.cc	/^    uint8_t _port_idx;$/;"	m	class:dpdk::dpdk_device	file:
_proto	arp.hh	/^    l3_protocol _proto;$/;"	m	class:net::arp
_proto	ip.hh	/^        ipv4_udp &_proto;$/;"	m	class:net::ipv4_udp::registration
_proto	native-stack-impl.hh	/^    Protocol& _proto;$/;"	m	class:net::final
_proto	udp.cc	/^    ipv4_udp& _proto;$/;"	m	class:net::ipv4_udp_impl::native_channel	file:
_proto_map	net.hh	/^    std::unordered_map<uint16_t, l3_rx_stream> _proto_map;$/;"	m	class:net::interface
_proto_num	arp.hh	/^    uint16_t _proto_num;$/;"	m	class:net::arp_for_protocol
_proto_num	net.hh	/^    eth_protocol_num _proto_num;$/;"	m	class:net::l3_protocol
_proxy_packetq	net.hh	/^    circular_buffer<packet> _proxy_packetq;$/;"	m	class:net::qp
_q	tcp.hh	/^        queue<connection> _q;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::listener
_q_index	virtio.cc	/^    uint16_t _q_index;$/;"	m	class:virtio::notifier_osv	file:
_qid	dpdk.cc	/^    uint8_t _qid;$/;"	m	class:dpdk::dpdk_qp	file:
_queue	udp.hh	/^    queue<udp_datagram> _queue;$/;"	m	struct:net::udp_channel_state
_queue_name	net.hh	/^    const std::string _queue_name;$/;"	m	class:net::qp
_queue_size	ip.hh	/^    int _queue_size = default_queue_size;$/;"	m	class:net::ipv4_udp
_queue_space	ip.hh	/^    semaphore _queue_space = {212992};$/;"	m	class:net::icmp
_queue_space	tcp.hh	/^    semaphore _queue_space = {212992};$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_queues	net.hh	/^    std::unique_ptr<qp*[]> _queues;$/;"	m	class:net::device
_queues_ready	dpdk.cc	/^    uint8_t _queues_ready = 0;$/;"	m	class:dpdk::dpdk_device	file:
_rcv	tcp.hh	/^        } _rcv;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb	typeref:struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
_rd	tcp.hh	/^    std::random_device _rd;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_recv	posix-stack.cc	/^    recv_ctx _recv;$/;"	m	class:net::posix_udp_channel	file:
_redir_table	dpdk.cc	/^    std::vector<uint8_t> _redir_table;$/;"	m	class:dpdk::dpdk_device	file:
_reg	udp.cc	/^    ipv4_udp::registration _reg;$/;"	m	class:net::ipv4_udp_impl::native_channel	file:
_remaining_buffers	virtio.cc	/^        unsigned _remaining_buffers = 0;$/;"	m	class:virtio::qp::rxq	file:
_remote_mss	tcp.hh	/^    uint16_t _remote_mss = 536;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_remote_win_scale	tcp.hh	/^    uint8_t _remote_win_scale = 0;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_result	dhcp.cc	/^    promise<bool, lease> _result;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_retransmit	tcp.hh	/^        timer<lowres_clock> _retransmit;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_retry_timer	dhcp.cc	/^    timer<> _retry_timer;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_reuseport	posix-stack.hh	/^    const bool _reuseport;$/;"	m	class:net::posix_ap_network_stack
_reuseport	posix-stack.hh	/^    const bool _reuseport;$/;"	m	class:net::posix_network_stack
_ring	dpdk.cc	/^        std::vector<tx_buf*> _ring;$/;"	m	class:dpdk::dpdk_qp::tx_buf_factory	file:
_ring	virtio.cc	/^        uint16_t _ring[];$/;"	m	struct:virtio::vring::avail_layout	file:
_ring	virtio.cc	/^        vring<packet_as_buffer_chain, complete> _ring;$/;"	m	class:virtio::qp::txq	file:
_ring	virtio.cc	/^        vring<single_buffer, complete> _ring;$/;"	m	class:virtio::qp::rxq	file:
_ring	xenfront.hh	/^        front_ring<T> *_ring;$/;"	m	class:xen::front_ring::entries
_ring	xenfront.hh	/^    T _ring[1];$/;"	m	class:xen::sring
_rss_hash	packet.hh	/^        std::experimental::optional<uint32_t> _rss_hash;$/;"	m	struct:net::final::impl
_rss_key	dpdk.cc	/^    rss_key_type _rss_key;$/;"	m	class:dpdk::dpdk_device	file:
_rss_table_bits	net.hh	/^    size_t _rss_table_bits = 0;$/;"	m	class:net::device
_rto_clk_granularity	tcp.hh	/^constexpr std::chrono::milliseconds tcp<InetTraits>::tcb::_rto_clk_granularity;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_rto_max	tcp.hh	/^constexpr std::chrono::milliseconds tcp<InetTraits>::tcb::_rto_max;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_rto_min	tcp.hh	/^constexpr std::chrono::milliseconds tcp<InetTraits>::tcb::_rto_min;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_rx	net.hh	/^    subscription<packet> _rx;$/;"	m	class:net::interface
_rx_evtchn	xenfront.cc	/^    port _rx_evtchn;$/;"	m	class:xen::xenfront_qp	file:
_rx_free_bufs	dpdk.cc	/^    std::vector<rte_mbuf*> _rx_free_bufs;$/;"	m	class:dpdk::dpdk_qp	file:
_rx_free_pkts	dpdk.cc	/^    std::vector<rte_mbuf*> _rx_free_pkts;$/;"	m	class:dpdk::dpdk_qp	file:
_rx_gc_poller	dpdk.cc	/^    reactor::poller _rx_gc_poller;$/;"	m	class:dpdk::dpdk_qp	file:
_rx_packets	arp.hh	/^    subscription<packet, ethernet_address> _rx_packets;$/;"	m	class:net::arp
_rx_packets	ip.hh	/^    subscription<packet, ethernet_address> _rx_packets;$/;"	m	class:net::ipv4
_rx_poller	dpdk.cc	/^    std::experimental::optional<reactor::poller> _rx_poller;$/;"	m	class:dpdk::dpdk_qp	file:
_rx_refs	xenfront.cc	/^    grant_head *_rx_refs;$/;"	m	class:xen::xenfront_qp	file:
_rx_ring	xenfront.cc	/^    front_ring<rx> _rx_ring;$/;"	m	class:xen::xenfront_qp	file:
_rx_stream	net.hh	/^    stream<packet> _rx_stream;$/;"	m	class:net::qp
_rx_xmem	dpdk.cc	/^    std::unique_ptr<void, free_deleter> _rx_xmem;$/;"	m	class:dpdk::dpdk_qp	file:
_rxq	virtio.cc	/^    rxq _rxq;$/;"	m	class:virtio::qp	file:
_rxq_storage	virtio.cc	/^    std::unique_ptr<char[], free_deleter> _rxq_storage;$/;"	m	class:virtio::qp	file:
_sa	posix-stack.hh	/^    socket_address _sa;$/;"	m	class:net::posix_ap_server_socket_impl
_sa	posix-stack.hh	/^    socket_address _sa;$/;"	m	class:net::posix_reuseport_server_socket_impl
_sa	posix-stack.hh	/^    socket_address _sa;$/;"	m	class:net::posix_server_socket_impl
_sack_received	tcp.hh	/^    bool _sack_received = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_send	dpdk.cc	/^    uint32_t _send(circular_buffer<packet>& pb, Func packet_to_tx_buf_p) {$/;"	f	class:dpdk::dpdk_qp	file:
_send	posix-stack.cc	/^    send_ctx _send;$/;"	m	class:net::posix_udp_channel	file:
_send_depth	proxy.cc	/^    size_t _send_depth = 0;$/;"	m	class:net::proxy_net_device	file:
_send_queue_length	proxy.cc	/^    static constexpr size_t _send_queue_length = 128;$/;"	m	class:net::proxy_net_device	file:
_session	tls.cc	/^    gnutls_session_t _session;$/;"	m	class:seastar::tls::session	file:
_session	tls.cc	/^    session& _session;$/;"	m	class:seastar::tls::session::sink_impl	file:
_session	tls.cc	/^    session& _session;$/;"	m	class:seastar::tls::session::source_impl	file:
_shared	virtio.cc	/^        avail_layout* _shared;$/;"	m	struct:virtio::vring::avail	file:
_shared	virtio.cc	/^        used_layout* _shared;$/;"	m	struct:virtio::vring::used	file:
_si	api.hh	/^    std::unique_ptr<net::socket_impl> _si;$/;"	m	class:seastar::seastar::socket
_snd	tcp.hh	/^        } _snd;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb	typeref:struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
_sock	dhcp.cc	/^    udp_channel _sock;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_sock	tls.cc	/^    ::server_socket _sock;$/;"	m	class:seastar::tls::server_session	file:
_sock	tls.cc	/^    std::unique_ptr<net::connected_socket_impl> _sock;$/;"	m	class:seastar::tls::session	file:
_socket	tls.cc	/^    seastar::socket _socket;$/;"	m	class:seastar::tls::tls_socket_impl	file:
_src	posix-stack.cc	/^    ipv4_addr _src;$/;"	m	class:net::posix_datagram	file:
_src	udp.cc	/^    ipv4_addr _src;$/;"	m	class:net::ipv4_udp_impl::native_datagram	file:
_src_addr	posix-stack.cc	/^        socket_address _src_addr;$/;"	m	struct:net::posix_udp_channel::recv_ctx	file:
_sring	xenfront.hh	/^    sring<T> *_sring;$/;"	m	class:xen::front_ring
_ssi	api.hh	/^    std::unique_ptr<net::server_socket_impl> _ssi;$/;"	m	class:seastar::server_socket
_stack	dhcp.cc	/^    ipv4 & _stack;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_start	packet.hh	/^        fragment* _start;$/;"	m	struct:net::final::pseudo_vector
_state	dhcp.cc	/^    state _state = state::NONE;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_state	tcp.hh	/^        tcp_state _state = CLOSED;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_state	udp.cc	/^    lw_shared_ptr<udp_channel_state> _state;$/;"	m	class:net::ipv4_udp_impl::native_channel	file:
_stats	dpdk.cc	/^    port_stats _stats;$/;"	m	class:dpdk::dpdk_device	file:
_stats	net.hh	/^    qp_stats _stats;$/;"	m	class:net::qp
_stats_collector	dpdk.cc	/^    timer<> _stats_collector;$/;"	m	class:dpdk::dpdk_device	file:
_stats_plugin_inst	dpdk.cc	/^    const std::string _stats_plugin_inst;$/;"	m	class:dpdk::dpdk_device	file:
_stats_plugin_name	dpdk.cc	/^    const std::string _stats_plugin_name;$/;"	m	class:dpdk::dpdk_device	file:
_stats_plugin_name	net.hh	/^    const std::string _stats_plugin_name;$/;"	m	class:net::qp
_supported_features	xenfront.cc	/^    static std::unordered_map<std::string, std::string> _supported_features;$/;"	m	class:xen::xenfront_qp	file:
_supported_features	xenfront.cc	/^xenfront_qp::_supported_features = {$/;"	m	class:xen::xenfront_qp	file:
_sw_reta	net.hh	/^    std::experimental::optional<std::array<uint8_t, 128>> _sw_reta;$/;"	m	class:net::qp
_system_trust_sem	tls.cc	/^    semaphore _system_trust_sem;$/;"	m	class:seastar::tls::certificate_credentials::impl	file:
_table	arp.hh	/^    std::unordered_map<l3addr, l2addr> _table;$/;"	m	class:net::arp_for
_tail	virtio.cc	/^        uint16_t _tail = 0;$/;"	m	struct:virtio::vring::used	file:
_tcb	tcp.hh	/^        lw_shared_ptr<tcb> _tcb;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::connection
_tcbs	tcp.hh	/^    std::unordered_map<connid, lw_shared_ptr<tcb>, connid_hash> _tcbs;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp
_tcp	ip.hh	/^    ipv4_tcp _tcp;$/;"	m	class:net::ipv4
_tcp	ip.hh	/^    std::unique_ptr<tcp<ipv4_traits>> _tcp;$/;"	m	class:net::final
_tcp	tcp.hh	/^        tcp& _tcp;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::listener
_tcp	tcp.hh	/^        tcp& _tcp;$/;"	m	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
_timeout_timer	arp.hh	/^        timer<> _timeout_timer;$/;"	m	struct:net::arp_for::resolution
_timer	dhcp.cc	/^    timer<> _timer;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_timer	native-stack.cc	/^    timer<> _timer;$/;"	m	class:net::native_network_stack	file:
_timestamps_received	tcp.hh	/^    bool _timestamps_received = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_tx_buf_factory	dpdk.cc	/^    tx_buf_factory _tx_buf_factory;$/;"	m	class:dpdk::dpdk_qp	file:
_tx_burst	dpdk.cc	/^    std::vector<rte_mbuf*> _tx_burst;$/;"	m	class:dpdk::dpdk_qp	file:
_tx_burst_idx	dpdk.cc	/^    uint16_t _tx_burst_idx = 0;$/;"	m	class:dpdk::dpdk_qp	file:
_tx_evtchn	xenfront.cc	/^    port _tx_evtchn;$/;"	m	class:xen::xenfront_qp	file:
_tx_gc_poller	dpdk.cc	/^    reactor::poller _tx_gc_poller;$/;"	m	class:dpdk::dpdk_qp	file:
_tx_packetq	net.hh	/^    circular_buffer<packet> _tx_packetq;$/;"	m	class:net::qp
_tx_poller	net.hh	/^    reactor::poller _tx_poller;$/;"	m	class:net::qp
_tx_refs	xenfront.cc	/^    grant_head *_tx_refs;$/;"	m	class:xen::xenfront_qp	file:
_tx_ring	xenfront.cc	/^    front_ring<tx> _tx_ring;$/;"	m	class:xen::xenfront_qp	file:
_txq	virtio.cc	/^    txq _txq;$/;"	m	class:virtio::qp	file:
_txq_storage	virtio.cc	/^    std::unique_ptr<char[], free_deleter> _txq_storage;$/;"	m	class:virtio::qp	file:
_type	tls.cc	/^    type _type;$/;"	m	class:seastar::tls::session	file:
_udp	ip.hh	/^    ipv4_udp _udp;$/;"	m	class:net::ipv4
_use_lro	dpdk.cc	/^    bool _use_lro;$/;"	m	class:dpdk::dpdk_device	file:
_used	virtio.cc	/^    used _used;$/;"	m	class:virtio::vring	file:
_used_elements	virtio.cc	/^        used_elem _used_elements[];$/;"	m	struct:virtio::vring::used_layout	file:
_used_event	virtio.cc	/^    std::atomic<uint16_t>* _used_event;$/;"	m	class:virtio::vring	file:
_user_queue_space	udp.hh	/^    semaphore _user_queue_space = {212992};$/;"	m	struct:net::udp_channel_state
_userspace	xenfront.cc	/^    bool _userspace;$/;"	m	class:xen::xenfront_device	file:
_vhost_fd	virtio.cc	/^    file_desc _vhost_fd;$/;"	m	class:virtio::qp_vhost	file:
_virtio	virtio.cc	/^    osv::assigned_virtio &_virtio;$/;"	m	class:virtio::notifier_osv	file:
_virtio	virtio.cc	/^    osv::assigned_virtio &_virtio;$/;"	m	class:virtio::qp_osv	file:
_waiters	arp.hh	/^        std::vector<promise<l2addr>> _waiters;$/;"	m	struct:net::arp_for::resolution
_win_scale_received	tcp.hh	/^    bool _win_scale_received = false;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
_window_opened	tcp.hh	/^            promise<> _window_opened;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
_xenstore	xenfront.cc	/^    xenstore* _xenstore = xenstore::instance();$/;"	m	class:xen::xenfront_device	file:
_xid	dhcp.cc	/^    uint32_t _xid = 0;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
_xmem	dpdk.cc	/^        std::unique_ptr<void, free_deleter> _xmem;$/;"	m	class:dpdk::dpdk_qp::tx_buf_factory	file:
abort_accept	native-stack-impl.hh	/^native_server_socket_impl<Protocol>::abort_accept() {$/;"	f	class:net::native_server_socket_impl
abort_accept	posix-stack.cc	/^posix_ap_server_socket_impl<Transport>::abort_accept() {$/;"	f	class:net::posix_ap_server_socket_impl
abort_accept	posix-stack.cc	/^posix_reuseport_server_socket_impl<Transport>::abort_accept() {$/;"	f	class:net::posix_reuseport_server_socket_impl
abort_accept	posix-stack.cc	/^posix_server_socket_impl<Transport>::abort_accept() {$/;"	f	class:net::posix_server_socket_impl
abort_accept	stack.cc	/^void server_socket::abort_accept() {$/;"	f	class:server_socket
abort_accept	tcp.hh	/^        void abort_accept() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::listener
abort_reader	tcp.hh	/^tcp<InetTraits>::tcb::abort_reader() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
abstract_credentials	tls.hh	/^    class abstract_credentials {$/;"	c	class:seastar::tls::dh_params
accept	native-stack-impl.hh	/^native_server_socket_impl<Protocol>::accept() {$/;"	f	class:net::native_server_socket_impl
accept	posix-stack.cc	/^future<connected_socket, socket_address> posix_ap_server_socket_impl<Transport>::accept() {$/;"	f	class:net::posix_ap_server_socket_impl
accept	posix-stack.cc	/^posix_reuseport_server_socket_impl<Transport>::accept() {$/;"	f	class:net::posix_reuseport_server_socket_impl
accept	posix-stack.cc	/^posix_server_socket_impl<Transport>::accept() {$/;"	f	class:net::posix_server_socket_impl
accept	stack.cc	/^future<connected_socket, socket_address> server_socket::accept() {$/;"	f	class:server_socket
accept	tcp.hh	/^        future<connection> accept() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::listener
ack	tcp.hh	/^    packed<tcp_seq> ack;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
ack_needs_on	tcp.hh	/^        bool ack_needs_on() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
add	arp.cc	/^void arp::add(uint16_t proto_num, arp_for_protocol* afp) {$/;"	f	class:net::arp
add_connected_tcb	tcp.hh	/^    void add_connected_tcb(lw_shared_ptr<tcb> tcbp, uint16_t local_port) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp
add_native_net_options_description	native-stack.cc	/^add_native_net_options_description(boost::program_options::options_description &opts) {$/;"	f	namespace:net
addr	posix-stack.hh	/^        socket_address addr;$/;"	m	struct:net::posix_ap_server_socket_impl::connection
addr	virtio.cc	/^    phys addr;$/;"	m	struct:virtio::buffer	file:
adjust_endianness	arp.hh	/^        void adjust_endianness(Adjuster a) { return a(htype, ptype); }$/;"	f	struct:net::arp::arp_hdr
adjust_endianness	arp.hh	/^        void adjust_endianness(Adjuster a) {$/;"	f	struct:net::arp_for::arp_hdr
adjust_endianness	dhcp.cc	/^        auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header
adjust_endianness	dhcp.cc	/^        auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_packet_base
adjust_endianness	dhcp.cc	/^        auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_payload
adjust_endianness	ethernet.hh	/^    auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::eth_hdr
adjust_endianness	ethernet.hh	/^    void adjust_endianness(Adjuster a) {}$/;"	f	struct:net::ethernet_address
adjust_endianness	ip.hh	/^    auto adjust_endianness(Adjuster a) { return a(ip); }$/;"	f	struct:net::ipv4_address
adjust_endianness	ip.hh	/^    auto adjust_endianness(Adjuster a) {$/;"	f	class:net::ip_hdr::frag_bits
adjust_endianness	ip.hh	/^    auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::icmp_hdr
adjust_endianness	tcp.hh	/^        void adjust_endianness(Adjuster a) { a(mss); }$/;"	f	struct:net::tcp_state::tcp_option::option_kind::option_len::mss
adjust_endianness	tcp.hh	/^        void adjust_endianness(Adjuster a) { a(t1, t2); }$/;"	f	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
adjust_endianness	tcp.hh	/^    void adjust_endianness(Adjuster a) { a(src_port, dst_port, seq, ack, window, checksum, urgent); }$/;"	f	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
adjust_endianness	udp.hh	/^    auto adjust_endianness(Adjuster a) {$/;"	f	struct:net::udp_hdr
align	tcp.hh	/^    static const uint8_t align = 4;$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
alloc_mempool_xmem	dpdk.cc	/^void* dpdk_qp<HugetlbfsMemBackend>::alloc_mempool_xmem($/;"	f	class:dpdk::dpdk_qp
alloc_one_rx_reference	xenfront.cc	/^void xenfront_qp::alloc_one_rx_reference(unsigned index) {$/;"	f	class:xen::xenfront_qp
alloc_rx_references	xenfront.cc	/^future<> xenfront_qp::alloc_rx_references() {$/;"	f	class:xen::xenfront_qp
allocate	packet.hh	/^        static std::unique_ptr<impl> allocate(size_t nr_frags) {$/;"	f	struct:net::final::impl
allocate_desc	virtio.cc	/^vring<BufferChain, Completion>::allocate_desc() {$/;"	f	class:virtio::vring
allocate_headroom	packet.hh	/^packet::allocate_headroom(size_t size) {$/;"	f	class:net::packet
allocate_if_needed	packet.hh	/^        static std::unique_ptr<impl> allocate_if_needed(std::unique_ptr<impl> old, size_t extra_frags) {$/;"	f	struct:net::final::impl
append	packet.hh	/^void packet::append(packet&& p) {$/;"	f	class:net::packet
apply_to	tls.cc	/^void seastar::tls::credentials_builder::apply_to(certificate_credentials& creds) const {$/;"	f	class:seastar::tls::credentials_builder
arp	arp.cc	/^arp::arp(interface* netif) : _netif(netif), _proto(netif, eth_protocol_num::arp, [this] { return get_packet(); })$/;"	f	class:net::arp
arp	arp.hh	/^class arp {$/;"	c	namespace:net
arp	const.hh	/^    ipv4 = 0x0800, arp = 0x0806, ipv6 = 0x86dd$/;"	m	class:net::ip_protocol_num::eth_protocol_num
arp_error	arp.hh	/^    arp_error(const std::string& msg) : std::runtime_error(msg) {}$/;"	f	class:net::arp_error
arp_error	arp.hh	/^class arp_error : public std::runtime_error {$/;"	c	namespace:net
arp_for	arp.hh	/^    explicit arp_for(arp& a) : arp_for_protocol(a, L3::arp_protocol_type()) {$/;"	f	class:net::arp_for
arp_for	arp.hh	/^class arp_for : public arp_for_protocol {$/;"	c	namespace:net
arp_for_protocol	arp.cc	/^arp_for_protocol::arp_for_protocol(arp& a, uint16_t proto_num)$/;"	f	class:net::arp_for_protocol
arp_for_protocol	arp.hh	/^class arp_for_protocol {$/;"	c	namespace:net
arp_hardware_type	ethernet.hh	/^    static constexpr uint16_t arp_hardware_type() { return 1; }$/;"	f	struct:net::ethernet
arp_hdr	arp.hh	/^    struct arp_hdr {$/;"	s	class:net::arp
arp_hdr	arp.hh	/^    struct arp_hdr {$/;"	s	class:net::arp_for
arp_learn	native-stack.cc	/^    void arp_learn(ethernet_address l2, ipv4_address l3) {$/;"	f	class:net::native_network_stack
arp_learn	native-stack.cc	/^void arp_learn(ethernet_address l2, ipv4_address l3)$/;"	f	namespace:net
arp_protocol_type	ip.hh	/^    static proto_type arp_protocol_type() { return proto_type(eth_protocol_num::ipv4); }$/;"	f	class:net::ipv4
arp_queue_full_error	arp.hh	/^    arp_queue_full_error() : arp_error("ARP waiter's queue is full") {}$/;"	f	class:net::arp_queue_full_error
arp_queue_full_error	arp.hh	/^class arp_queue_full_error : public arp_error {$/;"	c	namespace:net
arp_timeout_error	arp.hh	/^    arp_timeout_error() : arp_error("ARP timeout") {}$/;"	f	class:net::arp_timeout_error
arp_timeout_error	arp.hh	/^class arp_timeout_error : public arp_error {$/;"	c	namespace:net
as_cookie	dpdk.cc	/^void* as_cookie(struct rte_pktmbuf_pool_private& p) {$/;"	f
as_input_stream	packet-data-source.hh	/^input_stream<char> as_input_stream(packet&& p) {$/;"	f	namespace:net
as_posix_sockaddr	api.hh	/^    ::sockaddr& as_posix_sockaddr() { return u.sa; }$/;"	f	class:socket_address
as_posix_sockaddr	api.hh	/^    const ::sockaddr& as_posix_sockaddr() const { return u.sa; }$/;"	f	class:socket_address
as_posix_sockaddr_in	api.hh	/^    ::sockaddr_in& as_posix_sockaddr_in() { return u.in; }$/;"	f	class:socket_address
as_posix_sockaddr_in	api.hh	/^    const ::sockaddr_in& as_posix_sockaddr_in() const { return u.in; }$/;"	f	class:socket_address
avail	virtio.cc	/^    char* avail;$/;"	m	struct:virtio::ring_config	file:
avail	virtio.cc	/^    struct avail {$/;"	s	class:virtio::vring	file:
avail	virtio.cc	/^vring<BufferChain, Completion>::avail::avail(ring_config conf)$/;"	f	class:virtio::vring::avail
avail_layout	virtio.cc	/^    struct avail_layout {$/;"	s	class:virtio::vring	file:
available_descriptors	virtio.cc	/^    semaphore& available_descriptors() { return _available_descriptors; }$/;"	f	class:virtio::vring
bad	dpdk.cc	/^        } bad;$/;"	m	struct:dpdk::port_stats::__anon3	typeref:struct:dpdk::port_stats::__anon3::__anon5	file:
bad	dpdk.cc	/^        } bad;$/;"	m	struct:dpdk::port_stats::__anon6	typeref:struct:dpdk::port_stats::__anon6::__anon8	file:
bad	net.hh	/^        } bad;$/;"	m	struct:net::qp_stats::__anon9	typeref:struct:net::qp_stats::__anon9::__anon10
base	packet.hh	/^    char* base;$/;"	m	struct:net::fragment
begin	packet.hh	/^        fragment* begin() { return _start; }$/;"	f	struct:net::final::pseudo_vector
begin	virtio.cc	/^            auto begin() {$/;"	f	struct:virtio::qp::txq::packet_as_buffer_chain
bind_rx_evtchn	xenfront.cc	/^port xenfront_qp::bind_rx_evtchn(bool split) {$/;"	f	class:xen::xenfront_qp
bind_tx_evtchn	xenfront.cc	/^port xenfront_qp::bind_tx_evtchn(bool split) {$/;"	f	class:xen::xenfront_qp
blob	tls.hh	/^    typedef std::experimental::basic_string_view<char> blob;$/;"	t	namespace:seastar::tls
blob_wrapper	tls.cc	/^    blob_wrapper(const seastar::tls::blob& in)$/;"	f	class:blob_wrapper
blob_wrapper	tls.cc	/^class blob_wrapper: public gnutls_datum_t {$/;"	c	file:
bootp	dhcp.cc	/^        dhcp_header bootp;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_payload	file:
broadcast	dhcp.hh	/^        ipv4_address broadcast;$/;"	m	struct:net::dhcp::lease
broadcast_address	ethernet.hh	/^    static address broadcast_address() {$/;"	f	struct:net::ethernet
broadcast_address	ip.hh	/^    static address_type broadcast_address() { return ipv4_address(0xffffffff); }$/;"	f	class:net::ipv4
buf	virtio.cc	/^            std::unique_ptr<char[], free_deleter> buf;$/;"	m	struct:virtio::qp::rxq::buffer_and_virt	file:
buf_type	tls.cc	/^    typedef temporary_buffer<char> buf_type;$/;"	t	class:seastar::tls::session	file:
buffer	virtio.cc	/^struct buffer {$/;"	s	namespace:virtio	file:
buffer_and_virt	virtio.cc	/^        struct buffer_and_virt : buffer {$/;"	s	class:virtio::qp::rxq	file:
buffer_type	tls.cc	/^typedef std::basic_string<seastar::tls::blob::value_type, seastar::tls::blob::traits_type, std::allocator<seastar::tls::blob::value_type>> buffer_type;$/;"	t	file:
build_certificate_credentials	tls.cc	/^::shared_ptr<seastar::tls::certificate_credentials> seastar::tls::credentials_builder::build_certificate_credentials() const {$/;"	f	class:seastar::tls::credentials_builder
build_server_credentials	tls.cc	/^::shared_ptr<seastar::tls::server_credentials> seastar::tls::credentials_builder::build_server_credentials() const {$/;"	f	class:seastar::tls::credentials_builder
build_sw_reta	net.cc	/^void qp::build_sw_reta(const std::map<unsigned, float>& cpu_weights) {$/;"	f	class:net::qp
bunch	virtio.cc	/^            void bunch(uint64_t c) {$/;"	f	struct:virtio::qp::rxq::complete
bunch	virtio.cc	/^            void bunch(uint64_t c) {}$/;"	f	struct:virtio::qp::txq::complete
bytes	net.hh	/^    uint64_t bytes;      \/\/ total number of bytes$/;"	m	struct:net::qp_stats_good
can_send	tcp.hh	/^        uint32_t can_send() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
cert_status_to_string	tls.cc	/^    sstring cert_status_to_string(gnutls_certificate_type_t type, unsigned int status) {$/;"	f	class:seastar::tls::session
certificate_credentials	tls.cc	/^seastar::tls::certificate_credentials::certificate_credentials()$/;"	f	class:seastar::tls::certificate_credentials
certificate_credentials	tls.hh	/^    class certificate_credentials : public abstract_credentials {$/;"	c	class:seastar::tls::dh_params
chaddr	dhcp.cc	/^        uint8_t chaddr[16] = { 0, };     \/\/ Client hardware address.$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
check_frag0	dpdk.cc	/^        static bool check_frag0(packet& p)$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
check_port_link_status	dpdk.cc	/^void dpdk_device::check_port_link_status()$/;"	f	class:dpdk::dpdk_device
checksum	tcp.hh	/^    packed<uint16_t> checksum;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
checksummer	ip_checksum.hh	/^struct checksummer {$/;"	s	namespace:net
ciaddr	dhcp.cc	/^        ipv4_address ciaddr;  \/\/ Client IP address$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
cksum	udp.hh	/^    packed<uint16_t> cksum;$/;"	m	struct:net::udp_hdr
cleanup	tcp.hh	/^void tcp<InetTraits>::tcb::cleanup() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
clear_delayed_ack	tcp.hh	/^void tcp<InetTraits>::tcb::clear_delayed_ack() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
client_port	dhcp.cc	/^    static const uint16_t client_port = 68;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
client_port	dhcp.cc	/^const uint16_t net::dhcp::impl::client_port;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp::impl	file:
close	stack.cc	/^void net::udp_channel::close() {$/;"	f	class:net::udp_channel
close	tcp.hh	/^void tcp<InetTraits>::tcb::close() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
close_read	tcp.hh	/^void tcp<InetTraits>::connection::close_read() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
close_write	tcp.hh	/^void tcp<InetTraits>::connection::close_write() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
closed	tcp.hh	/^            bool closed = false;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
cmsg_with_pktinfo	posix-stack.cc	/^struct cmsg_with_pktinfo {$/;"	s	namespace:net	file:
code	ip.hh	/^    uint8_t code;$/;"	m	struct:net::icmp_hdr
common_config	virtio.cc	/^void qp::common_config(ring_config& r) {$/;"	f	class:virtio::qp
complete	virtio.cc	/^        struct complete {$/;"	s	class:virtio::qp::rxq	file:
complete	virtio.cc	/^        struct complete {$/;"	s	class:virtio::qp::txq	file:
complete_buffer	virtio.cc	/^qp::rxq::complete_buffer(single_buffer&& bc, size_t len) {$/;"	f	class:virtio::qp::rxq
complete_send	udp.hh	/^    void complete_send(size_t len) { _user_queue_space.signal(len); }$/;"	f	struct:net::udp_channel_state
config_ring_size	virtio.cc	/^static size_t config_ring_size(boost::program_options::variables_map &opts) {$/;"	f	namespace:virtio
configure_proxies	net.cc	/^void qp::configure_proxies(const std::map<unsigned, float>& cpu_weights) {$/;"	f	class:net::qp
conn_q	posix-stack.cc	/^thread_local std::unordered_multimap<::sockaddr_in, typename posix_ap_server_socket_impl<Transport>::connection> posix_ap_server_socket_impl<Transport>::conn_q;$/;"	m	class:net::posix_ap_server_socket_impl	file:
conn_q	posix-stack.hh	/^    static thread_local std::unordered_multimap<::sockaddr_in, connection> conn_q;$/;"	m	class:net::posix_ap_server_socket_impl
connect	api.hh	/^    future<connected_socket> connect(socket_address sa, socket_address local = socket_address(::sockaddr_in{AF_INET, INADDR_ANY, {0}}), seastar::transport proto = seastar::transport::TCP) {$/;"	f	class:seastar::network_stack
connect	stack.cc	/^future<connected_socket> seastar::socket::connect(socket_address sa, socket_address local, transport proto) {$/;"	f	class:seastar::socket
connect	tcp.hh	/^void tcp<InetTraits>::tcb::connect() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
connect	tls.cc	/^future<::connected_socket> seastar::tls::connect(::shared_ptr<certificate_credentials> cred, socket_address sa, socket_address local, sstring name) {$/;"	f	class:seastar::tls
connect	tls.cc	/^future<::connected_socket> seastar::tls::connect(::shared_ptr<certificate_credentials> cred, socket_address sa, sstring name) {$/;"	f	class:seastar::tls
connect_done	tcp.hh	/^        future<> connect_done() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
connected	tcp.hh	/^        future<> connected() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
connected_socket	api.hh	/^class connected_socket {$/;"	c	namespace:seastar
connected_socket	stack.cc	/^connected_socket::connected_socket($/;"	f	class:connected_socket
connected_socket	stack.cc	/^connected_socket::connected_socket()$/;"	f	class:connected_socket
connected_socket_impl	stack.hh	/^class connected_socket_impl {$/;"	c	namespace:net
connection	posix-stack.hh	/^        connection(pollable_fd xfd, socket_address xaddr) : fd(std::move(xfd)), addr(xaddr) {}$/;"	f	struct:net::posix_ap_server_socket_impl::connection
connection	posix-stack.hh	/^    struct connection {$/;"	s	class:net::posix_ap_server_socket_impl
connection	tcp.hh	/^        explicit connection(lw_shared_ptr<tcb> tcbp) : _tcb(std::move(tcbp)) { _tcb->_conn = this; }$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
connection	tcp.hh	/^    class connection {$/;"	c	class:net::tcp_state::tcp_option::option_kind::tcp
connid_hash	ip.hh	/^struct l4connid<InetTraits>::connid_hash : private std::hash<ipaddr>, private std::hash<uint16_t> {$/;"	s	class:net::ip_hdr::l4connid
copy	packet.hh	/^        static std::unique_ptr<impl> copy(impl* old) {$/;"	f	struct:net::final::impl
copy	packet.hh	/^        static std::unique_ptr<impl> copy(impl* old, size_t nr) {$/;"	f	struct:net::final::impl
copy_bytes	net.hh	/^    uint64_t copy_bytes; \/\/ bytes that were copied on L2 level$/;"	m	struct:net::qp_stats_good
copy_frags	net.hh	/^    uint64_t copy_frags; \/\/ fragments that were copied on L2 level$/;"	m	struct:net::qp_stats_good
copy_internal_fragment_to	packet.hh	/^        void copy_internal_fragment_to(impl* to) {$/;"	f	struct:net::final::impl
copy_one_data_buf	dpdk.cc	/^        static size_t copy_one_data_buf($/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
copy_one_frag	dpdk.cc	/^        static bool copy_one_frag(dpdk_qp& qp, fragment& frag,$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
copy_packet_to_cluster	dpdk.cc	/^        static void copy_packet_to_cluster(const packet& p, rte_mbuf* head) {$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
count	api.hh	/^    unsigned count; \/\/ TCP_KEEPCNT$/;"	m	struct:seastar::net::tcp_keepalive_params
count	api.hh	/^    unsigned count; \/\/ spp_pathmaxrt$/;"	m	struct:seastar::net::sctp_keepalive_params
crc	dpdk.cc	/^            uint64_t crc;          \/\/ packets with CRC error$/;"	m	struct:dpdk::port_stats::__anon3::__anon5	file:
create	native-stack.cc	/^    static future<std::unique_ptr<network_stack>> create(boost::program_options::variables_map opts) {$/;"	f	class:net::native_network_stack
create	posix-stack.hh	/^    static future<std::unique_ptr<network_stack>> create(boost::program_options::variables_map opts) {$/;"	f	class:net::posix_ap_network_stack
create	posix-stack.hh	/^    static future<std::unique_ptr<network_stack>> create(boost::program_options::variables_map opts) {$/;"	f	class:net::posix_network_stack
create_dpdk_net_device	dpdk.cc	/^std::unique_ptr<net::device> create_dpdk_net_device($/;"	f
create_native_net_device	native-stack.cc	/^void create_native_net_device(boost::program_options::variables_map opts) {$/;"	f	namespace:net
create_native_stack	native-stack.cc	/^void create_native_stack(boost::program_options::variables_map opts, std::shared_ptr<device> dev) {$/;"	f	namespace:net
create_proxy_net_device	proxy.cc	/^std::unique_ptr<qp> create_proxy_net_device(unsigned master_cpu, device* dev) {$/;"	f	namespace:net
create_virtio_net_device	virtio.cc	/^std::unique_ptr<net::device> create_virtio_net_device(boost::program_options::variables_map opts) {$/;"	f
create_xenfront_net_device	xenfront.cc	/^std::unique_ptr<net::device> create_xenfront_net_device(boost::program_options::variables_map opts, bool userspace) {$/;"	f	namespace:xen
credentials_builder	tls.hh	/^    class credentials_builder : public abstract_credentials {$/;"	c	class:seastar::tls::dh_params
csum	ip.hh	/^    packed<uint16_t> csum;$/;"	m	class:net::ip_hdr::frag_bits
csum	ip.hh	/^    packed<uint16_t> csum;$/;"	m	struct:net::icmp_hdr
csum	ip_checksum.hh	/^    __int128 csum = 0;$/;"	m	struct:net::checksummer
csum	net.hh	/^            uint64_t csum;         \/\/ packets with bad checksum$/;"	m	struct:net::qp_stats::__anon9::__anon10
csum_blank	xenfront.hh	/^        uint16_t csum_blank : 1;$/;"	m	struct:xen::netif_tx_request::__anon14
csum_offset	virtio.cc	/^        uint16_t csum_offset;$/;"	m	struct:virtio::qp::net_hdr	file:
csum_start	virtio.cc	/^        uint16_t csum_start;$/;"	m	struct:virtio::qp::net_hdr	file:
cwnd	tcp.hh	/^            uint32_t cwnd;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
data	ip.hh	/^        ipv4_packet_merger data;$/;"	m	struct:net::ipv4::frag
data	net.hh	/^    uint8_t data[64];$/;"	m	class:net::forward_hash
data	tcp.hh	/^            std::deque<packet> data;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
data	tcp.hh	/^            std::deque<unacked_segment> data;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
data_len	tcp.hh	/^            uint16_t data_len;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::unacked_segment
data_offset	tcp.hh	/^    uint8_t data_offset : 4;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
data_segment_acked	tcp.hh	/^uint32_t tcp<InetTraits>::tcb::data_segment_acked(tcp_seq seg_ack) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
data_validated	xenfront.hh	/^        uint16_t data_validated : 1;$/;"	m	struct:xen::netif_tx_request::__anon14
debug_mode_adjust_fragments	virtio.cc	/^qp::rxq::debug_mode_adjust_fragments() {$/;"	f	class:virtio::qp::rxq
dec_pending	tcp.hh	/^        void dec_pending() { _pending--; }$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::listener
def_rx_conf	dpdk.cc	/^    const rte_eth_rxconf* def_rx_conf() const {$/;"	f	class:dpdk::dpdk_device
def_tx_conf	dpdk.cc	/^    const rte_eth_txconf* def_tx_conf() const {$/;"	f	class:dpdk::dpdk_device
default_nr_frags	packet.cc	/^constexpr size_t packet::default_nr_frags;$/;"	m	class:net::packet	file:
default_nr_frags	packet.hh	/^    static constexpr size_t default_nr_frags = 4;$/;"	m	class:net::final
default_queue_size	ip.hh	/^    static const int default_queue_size;$/;"	m	class:net::ipv4_udp
default_queue_size	udp.cc	/^const int ipv4_udp::default_queue_size = 1024;$/;"	m	class:net::ipv4_udp	file:
default_ring_size	dpdk.cc	/^static constexpr uint16_t default_ring_size      = 512;$/;"	m	namespace:dpdk	file:
default_rsskey_40bytes	toeplitz.hh	/^static const rss_key_type default_rsskey_40bytes = {$/;"	v
default_rsskey_52bytes	toeplitz.hh	/^static const rss_key_type default_rsskey_52bytes = {$/;"	v
default_timeout	dhcp.cc	/^const steady_clock_type::duration net::dhcp::default_timeout = std::chrono::duration_cast<steady_clock_type::duration>(std::chrono::seconds(30));$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
default_timeout	dhcp.hh	/^    static const steady_clock_type::duration default_timeout;$/;"	m	class:net::dhcp
del	arp.cc	/^void arp::del(uint16_t proto_num) {$/;"	f	class:net::arp
desc	virtio.cc	/^    class desc {$/;"	c	class:virtio::vring	file:
descs	virtio.cc	/^    char* descs;$/;"	m	struct:virtio::ring_config	file:
device	net.hh	/^    device() {$/;"	f	class:net::device
device	net.hh	/^class device {$/;"	c	namespace:net
device	virtio.cc	/^    device(boost::program_options::variables_map opts)$/;"	f	class:virtio::device
device	virtio.cc	/^class device : public net::device {$/;"	c	namespace:virtio	file:
df	ip.hh	/^    bool df() { return frag & (1 << uint8_t(frag_bits::df)); }$/;"	f	class:net::ip_hdr::frag_bits
df	ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	m	class:net::ip_hdr::frag_bits
dh_level_key	tls.cc	/^static const sstring dh_level_key = "dh_level";$/;"	v	file:
dh_params	tls.cc	/^    void dh_params(const tls::dh_params& dh) {$/;"	f	class:seastar::tls::certificate_credentials::impl
dh_params	tls.cc	/^seastar::tls::dh_params::dh_params(const blob& b, x509_crt_format fmt)$/;"	f	class:seastar::tls::dh_params
dh_params	tls.cc	/^seastar::tls::dh_params::dh_params(level lvl) : _impl(std::make_unique<impl>(lvl))$/;"	f	class:seastar::tls::dh_params
dh_params	tls.hh	/^    class dh_params {$/;"	c	namespace:seastar::tls
dhcp	dhcp.cc	/^net::dhcp::dhcp(dhcp && v)$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
dhcp	dhcp.cc	/^net::dhcp::dhcp(ipv4 & ip)$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
dhcp	dhcp.hh	/^class dhcp {$/;"	c	namespace:net
dhcp_header	dhcp.cc	/^    struct dhcp_header {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
dhcp_packet_base	dhcp.cc	/^    struct dhcp_packet_base {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
dhcp_payload	dhcp.cc	/^    struct dhcp_payload {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
dhcp_server	dhcp.hh	/^        ipv4_address dhcp_server;$/;"	m	struct:net::dhcp::lease
dhp	dhcp.cc	/^        dhcp_payload dhp;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_packet_base	file:
discover	dhcp.cc	/^net::dhcp::result_type net::dhcp::discover(const steady_clock_type::duration & timeout) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
dispatch_packet	net.cc	/^future<> interface::dispatch_packet(packet p) {$/;"	f	class:net::interface
do_closed	tcp.hh	/^        void do_closed() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
do_complete	virtio.cc	/^bool vring<BufferChain, Completion>::do_complete() {$/;"	f	class:virtio::vring
do_established	tcp.hh	/^        void do_established() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
do_local_fin_acked	tcp.hh	/^        void do_local_fin_acked() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
do_one_frag	dpdk.cc	/^        static bool do_one_frag(DoOneBufFunc do_one_buf, dpdk_qp& qp,$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
do_reset	tcp.hh	/^        void do_reset() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
do_setup_isn	tcp.hh	/^        void do_setup_isn() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
do_syn_received	tcp.hh	/^        void do_syn_received() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
do_syn_sent	tcp.hh	/^        void do_syn_sent() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
do_time_wait	tcp.hh	/^        void do_time_wait() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
dpdk	dpdk.cc	/^namespace dpdk {$/;"	n	file:
dpdk	dpdk.hh	/^namespace dpdk {$/;"	n
dpdk_device	dpdk.cc	/^    dpdk_device(uint8_t port_idx, uint16_t num_queues, bool use_lro,$/;"	f	class:dpdk::dpdk_device
dpdk_device	dpdk.cc	/^class dpdk_device : public device {$/;"	c	namespace:dpdk	file:
dpdk_qp	dpdk.cc	/^class dpdk_qp : public net::qp {$/;"	c	namespace:dpdk	file:
dpdk_qp	dpdk.cc	/^dpdk_qp<HugetlbfsMemBackend>::dpdk_qp(dpdk_device* dev, uint8_t qid,$/;"	f	class:dpdk::dpdk_qp
dropped	dpdk.cc	/^            uint64_t dropped;      \/\/ missed packets (e.g. full FIFO)$/;"	m	struct:dpdk::port_stats::__anon3::__anon5	file:
dscp	ip.hh	/^    uint8_t dscp : 6;$/;"	m	struct:net::ip_hdr
dst_ip	ip.hh	/^    ipv4_address dst_ip;$/;"	m	class:net::ip_hdr::frag_bits
dst_ip	ip.hh	/^    ipv4_address dst_ip;$/;"	m	struct:net::ipv4_frag_id
dst_mac	ethernet.hh	/^    ethernet_address dst_mac;$/;"	m	struct:net::eth_hdr
dst_port	tcp.hh	/^    packed<uint16_t> dst_port;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
dst_port	udp.hh	/^    packed<uint16_t> dst_port;$/;"	m	struct:net::udp_hdr
dump	xenfront.hh	/^    void dump() {$/;"	f	class:xen::front_ring
dump	xenfront.hh	/^    void dump() {$/;"	f	class:xen::sring
dump	xenfront.hh	/^    void dump(const char *str, netif_rx_response &r) {$/;"	f	class:xen::front_ring
dump	xenfront.hh	/^    void dump(const char *str, netif_tx_response &r) {$/;"	f	class:xen::front_ring
dupacks	tcp.hh	/^            uint16_t dupacks = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
e_dst	ip.hh	/^        ethernet_address e_dst;$/;"	m	struct:net::ipv4_traits::l4packet
echo_reply	ip.hh	/^        echo_reply = 0,$/;"	m	class:net::icmp_hdr::msg_type
echo_request	ip.hh	/^        echo_request = 8,$/;"	m	class:net::icmp_hdr::msg_type
ecn	ip.hh	/^    uint8_t ecn : 2;$/;"	m	struct:net::ip_hdr
end	packet.hh	/^        fragment* end() { return _finish; }$/;"	f	struct:net::final::pseudo_vector
end	virtio.cc	/^            auto end() {$/;"	f	struct:virtio::qp::txq::packet_as_buffer_chain
end_idx	net.hh	/^    size_t end_idx = 0;$/;"	m	class:net::forward_hash
entries	xenfront.hh	/^        entries(front_ring<T> *ring) : _ring(ring) {}$/;"	f	class:xen::front_ring::entries
entries	xenfront.hh	/^    class entries {$/;"	c	class:xen::front_ring
entries	xenfront.hh	/^    entries entries;$/;"	m	class:xen::front_ring
eof	tls.cc	/^    bool eof() const {$/;"	f	class:seastar::tls::session
eol	tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
eol	tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
eol	tcp.hh	/^    struct eol {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
eth_hdr	ethernet.hh	/^struct eth_hdr {$/;"	s	namespace:net
eth_hdr_len	const.hh	/^const uint8_t eth_hdr_len = 14;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
eth_proto	ethernet.hh	/^    packed<uint16_t> eth_proto;$/;"	m	struct:net::eth_hdr
eth_protocol_num	const.hh	/^enum class eth_protocol_num : uint16_t {$/;"	c	class:net::ip_protocol_num
ethernet	ethernet.hh	/^struct ethernet {$/;"	s	namespace:net
ethernet_address	ethernet.hh	/^    ethernet_address() {}$/;"	f	struct:net::ethernet_address
ethernet_address	ethernet.hh	/^    ethernet_address(const uint8_t *eaddr) {$/;"	f	struct:net::ethernet_address
ethernet_address	ethernet.hh	/^    ethernet_address(std::initializer_list<uint8_t> eaddr) {$/;"	f	struct:net::ethernet_address
ethernet_address	ethernet.hh	/^struct ethernet_address {$/;"	s	namespace:net
event_index	virtio.cc	/^    bool event_index;$/;"	m	struct:virtio::ring_config	file:
exit_fast_recovery	tcp.hh	/^        void exit_fast_recovery() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
extra_info	xenfront.hh	/^        uint16_t extra_info : 1;$/;"	m	struct:xen::netif_tx_request::__anon14
f_ack	tcp.hh	/^    uint8_t f_ack : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_fin	tcp.hh	/^    uint8_t f_fin : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_psh	tcp.hh	/^    uint8_t f_psh : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_rst	tcp.hh	/^    uint8_t f_rst : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_syn	tcp.hh	/^    uint8_t f_syn : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
f_urg	tcp.hh	/^    uint8_t f_urg : 1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
fast_retransmit	tcp.hh	/^void tcp<InetTraits>::tcb::fast_retransmit() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
fd	posix-stack.hh	/^        pollable_fd fd;$/;"	m	struct:net::posix_ap_server_socket_impl::connection
features	virtio.cc	/^    uint64_t features() {$/;"	f	class:virtio::device
file	dhcp.cc	/^        char file[128] = { 0, };         \/\/ unused$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
fill	tcp.cc	/^uint8_t tcp_option::fill(tcp_hdr* th, uint8_t options_size) {$/;"	f	class:net::tcp_option
fin_needs_on	tcp.hh	/^        bool fin_needs_on() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
fin_retransmit	tcp.hh	/^            unsigned fin_retransmit = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
final	api.hh	/^class udp_datagram final {$/;"	c	namespace:seastar::net
final	ip.hh	/^class ipv4_icmp final : public ip_protocol {$/;"	c	namespace:net
final	ip.hh	/^class ipv4_tcp final : public ip_protocol {$/;"	c	namespace:net
final	native-stack-impl.hh	/^class native_connected_socket_impl<Protocol>::native_data_sink_impl final$/;"	c	namespace:net
final	native-stack-impl.hh	/^class native_connected_socket_impl<Protocol>::native_data_source_impl final$/;"	c	namespace:net
final	native-stack-impl.hh	/^class native_socket_impl final : public socket_impl {$/;"	c	namespace:net
final	packet-data-source.hh	/^class packet_data_source final : public data_source_impl {$/;"	c	namespace:net
final	packet.hh	/^class packet final {$/;"	c	namespace:net
final	posix-stack.cc	/^class posix_connected_socket_impl final : public connected_socket_impl, posix_connected_socket_operations<Transport> {$/;"	c	namespace:net	file:
final	posix-stack.cc	/^class posix_socket_impl final : public socket_impl {$/;"	c	namespace:net	file:
final	posix-stack.hh	/^class posix_data_source_impl final : public data_source_impl {$/;"	c	namespace:net
finish_handshake_op	tls.cc	/^    future<> finish_handshake_op(int res, Func&& f) {$/;"	f	class:seastar::tls::session
first_rto_sample	tcp.hh	/^            bool first_rto_sample = true;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
flags	dhcp.cc	/^        packed<uint16_t> flags = 0;         \/\/ Flags$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
flags	virtio.cc	/^        struct flags {$/;"	s	class:virtio::vring::desc	file:
flags	virtio.cc	/^        struct flags {$/;"	s	struct:virtio::vring::avail_layout	file:
flags	xenfront.hh	/^    uint16_t flags;        \/* NETRXF_* *\/$/;"	m	struct:xen::netif_rx_response
flags	xenfront.hh	/^    } flags;$/;"	m	struct:xen::netif_tx_request	typeref:struct:xen::netif_tx_request::__anon14
flags_reserved	virtio.cc	/^        uint8_t flags_reserved : 7;$/;"	m	struct:virtio::qp::net_hdr	file:
flight_size	tcp.hh	/^        uint32_t flight_size() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
flush	tls.cc	/^    future<> flush() {$/;"	f	class:seastar::tls::session
foreign_ip	ip.hh	/^    ipaddr foreign_ip;$/;"	m	struct:net::l4connid
foreign_port	ip.hh	/^    uint16_t foreign_port;$/;"	m	struct:net::l4connid
foreign_will_not_send	tcp.hh	/^        bool foreign_will_not_send() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
forward	arp.cc	/^bool arp::forward(forward_hash& out_hash_data, packet& p, size_t off) {$/;"	f	class:net::arp
forward	arp.hh	/^    virtual bool forward(forward_hash& out_hash_data, packet& p, size_t off) { return false; }$/;"	f	class:net::arp_for_protocol
forward	ip.cc	/^bool ipv4::forward(forward_hash& out_hash_data, packet& p, size_t off)$/;"	f	class:net::ipv4
forward	ip.hh	/^    virtual bool forward(forward_hash& out_hash_data, packet& p, size_t off) { return true; }$/;"	f	class:net::ip_protocol
forward	net.cc	/^void interface::forward(unsigned cpuid, packet p) {$/;"	f	class:net::interface
forward	net.hh	/^        std::function<bool (forward_hash&, packet&, size_t)> forward;$/;"	m	struct:net::interface::l3_rx_stream
forward	tcp.cc	/^bool ipv4_tcp::forward(forward_hash& out_hash_data, packet& p, size_t off) {$/;"	f	class:net::ipv4_tcp
forward	tcp.hh	/^bool tcp<InetTraits>::forward(forward_hash& out_hash_data, packet& p, size_t off) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp
forward	udp.cc	/^bool ipv4_udp::forward(forward_hash& out_hash_data, packet& p, size_t off)$/;"	f	class:net::ipv4_udp
forward_dst	net.hh	/^    unsigned forward_dst(unsigned src_cpuid, Func&& hashfn) {$/;"	f	class:net::device
forward_hash	net.hh	/^class forward_hash {$/;"	c	namespace:net
frag	ip.hh	/^    packed<uint16_t> frag;$/;"	m	struct:net::ip_hdr
frag	ip.hh	/^    struct frag {$/;"	s	class:net::ipv4
frag	packet.hh	/^    fragment frag(unsigned idx) const { return _impl->_frags[idx]; }$/;"	f	class:net::final
frag	packet.hh	/^    fragment& frag(unsigned idx) { return _impl->_frags[idx]; }$/;"	f	class:net::final
frag_arm	ip.hh	/^    void frag_arm() {$/;"	f	class:net::ipv4
frag_arm	ip.hh	/^    void frag_arm(clock_type::time_point now) {$/;"	f	class:net::ipv4
frag_bits	ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	c	struct:net::ip_hdr
frag_drop	ip.cc	/^void ipv4::frag_drop(ipv4_frag_id frag_id, uint32_t dropped_size) {$/;"	f	class:net::ipv4
frag_iter	tls.cc	/^    typedef net::fragment* frag_iter;$/;"	t	class:seastar::tls::session::sink_impl	file:
frag_limit_mem	ip.cc	/^void ipv4::frag_limit_mem() {$/;"	f	class:net::ipv4
frag_timeout	ip.cc	/^void ipv4::frag_timeout() {$/;"	f	class:net::ipv4
fragment	packet.hh	/^struct fragment {$/;"	s	namespace:net
fragment_array	packet.hh	/^    fragment* fragment_array() const { return _impl->_frags; }$/;"	f	class:net::final
fragment_to_buffer	virtio.cc	/^        static buffer fragment_to_buffer(fragment f) {$/;"	f	class:virtio::qp::txq	file:
fragments	packet.hh	/^        pseudo_vector fragments() { return { _frags, _nr_frags }; }$/;"	f	struct:net::final::impl
fragments	packet.hh	/^    pseudo_vector fragments() const { return { _impl->_frags, _impl->_nr_frags }; }$/;"	f	class:net::final
free_index	xenfront.cc	/^void front_ring<T>::entries::free_index(unsigned id) {$/;"	f	class:xen::front_ring::entries
free_on_cpu	packet.cc	/^packet packet::free_on_cpu(unsigned cpu, std::function<void()> cb)$/;"	f	class:net::packet
from_file	tls.cc	/^future<seastar::tls::dh_params> seastar::tls::dh_params::from_file($/;"	f	class:seastar::tls::dh_params
from_file	tls.cc	/^future<seastar::tls::x509_cert> seastar::tls::x509_cert::from_file($/;"	f	class:seastar::tls::x509_cert
from_mbuf	dpdk.cc	/^dpdk_qp<false>::from_mbuf(rte_mbuf* m)$/;"	f	class:dpdk::dpdk_qp
from_mbuf	dpdk.cc	/^inline std::experimental::optional<packet> dpdk_qp<true>::from_mbuf(rte_mbuf* m)$/;"	f	class:dpdk::dpdk_qp
from_mbuf_lro	dpdk.cc	/^dpdk_qp<false>::from_mbuf_lro(rte_mbuf* m)$/;"	f	class:dpdk::dpdk_qp
from_mbuf_lro	dpdk.cc	/^dpdk_qp<true>::from_mbuf_lro(rte_mbuf* m)$/;"	f	class:dpdk::dpdk_qp
from_packet_copy	dpdk.cc	/^        static tx_buf* from_packet_copy(packet&& p, dpdk_qp& qp) {$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
from_packet_zc	dpdk.cc	/^        static tx_buf* from_packet_zc(packet&& p, dpdk_qp& qp) {$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
from_static_data	packet.hh	/^    static packet from_static_data(const char* data, size_t len) {$/;"	f	class:net::final
from_transport_ptr	tls.cc	/^    static session * from_transport_ptr(gnutls_transport_ptr_t ptr) {$/;"	f	class:seastar::tls::session
front_ring	xenfront.hh	/^    front_ring(gntref r, xenfront_qp& dev)$/;"	f	class:xen::front_ring
front_ring	xenfront.hh	/^class front_ring {$/;"	c	namespace:xen
full	tcp.hh	/^        bool full() { return _pending + _q.size() >= _q.max_size(); }$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::listener
gateway	dhcp.hh	/^        ipv4_address gateway;$/;"	m	struct:net::dhcp::lease
gc	dpdk.cc	/^        bool gc() {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory
gc_count	dpdk.cc	/^        static constexpr int gc_count = 1;$/;"	m	class:dpdk::dpdk_qp::tx_buf_factory	file:
get	dpdk.cc	/^        tx_buf* get() {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory
get	ip_checksum.cc	/^uint16_t checksummer::get() const {$/;"	f	class:net::checksummer
get	posix-stack.cc	/^posix_data_source_impl::get() {$/;"	f	class:net::posix_data_source_impl
get	tls.cc	/^    static std::unique_ptr<connected_socket_impl> get(connected_socket s) {$/;"	f	class:net::get_impl
get_assembled_packet	ip.cc	/^packet ipv4::frag::get_assembled_packet(ethernet_address from, ethernet_address to) {$/;"	f	class:net::ipv4::frag
get_data	api.hh	/^    packet& get_data() { return _impl->get_data(); }$/;"	f	class:seastar::net::final
get_dpdk_net_options_description	dpdk.cc	/^get_dpdk_net_options_description()$/;"	f
get_dst	api.hh	/^    ipv4_addr get_dst() { return _impl->get_dst(); }$/;"	f	class:seastar::net::final
get_dst_port	api.hh	/^    uint16_t get_dst_port() { return _impl->get_dst_port(); }$/;"	f	class:seastar::net::final
get_header	packet.hh	/^Header* packet::get_header(size_t offset) {$/;"	f	class:net::packet
get_header	packet.hh	/^char* packet::get_header(size_t offset, size_t size) {$/;"	f	class:net::packet
get_impl	tls.cc	/^class net::get_impl {$/;"	c	class:net	file:
get_index	xenfront.cc	/^unsigned front_ring<T>::entries::get_index() {$/;"	f	class:xen::front_ring::entries
get_ipv4_filter	dhcp.cc	/^net::ip_packet_filter* net::dhcp::get_ipv4_filter() {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
get_isn	tcp.hh	/^tcp_seq tcp<InetTraits>::tcb::get_isn() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
get_keepalive	native-stack-impl.hh	/^bool native_connected_socket_impl<Protocol>::get_keepalive() const {$/;"	f	class:net::native_connected_socket_impl
get_keepalive	posix-stack.cc	/^    bool get_keepalive(file_desc& _fd) const {$/;"	f	class:net::posix_connected_socket_operations
get_keepalive	stack.cc	/^bool connected_socket::get_keepalive() const {$/;"	f	class:connected_socket
get_keepalive_parameters	native-stack-impl.hh	/^keepalive_params native_connected_socket_impl<Protocol>::get_keepalive_parameters() const {$/;"	f	class:net::native_connected_socket_impl
get_keepalive_parameters	posix-stack.cc	/^    keepalive_params get_keepalive_parameters(file_desc& _fd) const {$/;"	f	class:net::posix_connected_socket_operations
get_keepalive_parameters	stack.cc	/^net::keepalive_params connected_socket::get_keepalive_parameters() const {$/;"	f	class:connected_socket
get_l2_dst_address	ip.cc	/^future<ethernet_address> ipv4::get_l2_dst_address(ipv4_address to) {$/;"	f	class:net::ipv4
get_l2_dst_address	ip.hh	/^future<ethernet_address> ipv4_l4<ProtoNum>::get_l2_dst_address(ipv4_address to) {$/;"	f	class:net::ipv4_l4
get_len	virtio.cc	/^        uint32_t get_len() { return _len; }$/;"	f	class:virtio::vring::desc
get_nodelay	native-stack-impl.hh	/^native_connected_socket_impl<Protocol>::get_nodelay() const {$/;"	f	class:net::native_connected_socket_impl
get_nodelay	posix-stack.cc	/^    bool get_nodelay(file_desc& _fd) const {$/;"	f	class:net::posix_connected_socket_operations
get_nodelay	stack.cc	/^bool connected_socket::get_nodelay() const {$/;"	f	class:connected_socket
get_one_completed	dpdk.cc	/^        tx_buf* get_one_completed() {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory	file:
get_packet	arp.cc	/^std::experimental::optional<l3_protocol::l3packet> arp::get_packet() {$/;"	f	class:net::arp
get_packet	ip.cc	/^std::experimental::optional<l3_protocol::l3packet> ipv4::get_packet() {$/;"	f	class:net::ipv4
get_packet	tcp.hh	/^std::experimental::optional<typename InetTraits::l4packet> tcp<InetTraits>::tcb::get_packet() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
get_size	tcp.cc	/^uint8_t tcp_option::get_size(bool syn_on, bool ack_on) {$/;"	f	class:net::tcp_option
get_src	api.hh	/^    ipv4_addr get_src() { return _impl->get_src(); }$/;"	f	class:seastar::net::final
get_tcp	ip.hh	/^    tcp<ipv4_traits>& get_tcp() { return *_tcp._tcp; }$/;"	f	class:net::ipv4
get_transmit_packet	tcp.hh	/^packet tcp<InetTraits>::tcb::get_transmit_packet() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
get_tx_buf	dpdk.cc	/^    tx_buf* get_tx_buf() { return _tx_buf_factory.get(); }$/;"	f	class:dpdk::dpdk_qp
get_udp	ip.hh	/^    ipv4_udp& get_udp() { return _udp; }$/;"	f	class:net::ipv4
get_virtio_net_options_description	virtio.cc	/^get_virtio_net_options_description()$/;"	f
get_xenfront_net_options_description	xenfront.cc	/^get_xenfront_net_options_description() {$/;"	f	namespace:xen
getconfig	virtio.cc	/^        const ring_config& getconfig() {$/;"	f	class:virtio::qp::rxq
getconfig	virtio.cc	/^        const ring_config& getconfig() {$/;"	f	class:virtio::qp::txq
getconfig	virtio.cc	/^    const ring_config& getconfig() {$/;"	f	class:virtio::vring
giaddr	dhcp.cc	/^        ipv4_address giaddr;  \/\/ Relay agent IP address$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
glts_errorc	tls.cc	/^static const gnutls_error_category glts_errorc;$/;"	v	file:
gnutls_error_category	tls.cc	/^class gnutls_error_category : public std::error_category {$/;"	c	file:
gnutlsinit	tls.cc	/^    gnutlsinit() {$/;"	f	class:gnutlsinit
gnutlsinit	tls.cc	/^class gnutlsinit {$/;"	c	file:
gnutlsobj	tls.cc	/^    gnutlsobj() {$/;"	f	class:gnutlsobj
gnutlsobj	tls.cc	/^class gnutlsobj {$/;"	c	file:
good	dpdk.cc	/^        } good;$/;"	m	struct:dpdk::port_stats::__anon3	typeref:struct:dpdk::port_stats::__anon3::__anon4	file:
good	dpdk.cc	/^        } good;$/;"	m	struct:dpdk::port_stats::__anon6	typeref:struct:dpdk::port_stats::__anon6::__anon7	file:
good	net.hh	/^        struct qp_stats_good good;$/;"	m	struct:net::qp_stats::__anon11	typeref:struct:net::qp_stats::__anon11::qp_stats_good
good	net.hh	/^        struct qp_stats_good good;$/;"	m	struct:net::qp_stats::__anon9	typeref:struct:net::qp_stats::__anon9::qp_stats_good
gref	xenfront.hh	/^    uint32_t gref;$/;"	m	struct:xen::netif_rx_request
gref	xenfront.hh	/^    uint32_t gref;$/;"	m	struct:xen::netif_tx_request
gso_ecn	virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon13	file:
gso_none	virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon13	file:
gso_size	virtio.cc	/^        uint16_t gso_size;$/;"	m	struct:virtio::qp::net_hdr	file:
gso_tcpv4	virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon13	file:
gso_tcpv6	virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon13	file:
gso_type	virtio.cc	/^        uint8_t gso_type;$/;"	m	struct:virtio::qp::net_hdr	file:
gso_udp	virtio.cc	/^        enum { gso_none = 0, gso_tcpv4 = 1, gso_udp = 3, gso_tcpv6 = 4, gso_ecn = 0x80 };$/;"	e	enum:virtio::qp::net_hdr::__anon13	file:
gtls_chk	tls.cc	/^static void gtls_chk(int res) {$/;"	f	file:
gw_address	ip.cc	/^ipv4_address ipv4::gw_address() const {$/;"	f	class:net::ipv4
handle_error	tls.cc	/^    handle_error(int res) {$/;"	f	class:seastar::tls::session
handle_output_error	tls.cc	/^    handle_output_error(int res) {$/;"	f	class:seastar::tls::session
handle_received_packet	ip.cc	/^ipv4::handle_received_packet(packet p, ethernet_address from) {$/;"	f	class:net::ipv4
handle_request	arp.hh	/^arp_for<L3>::handle_request(arp_hdr* ah) {$/;"	f	class:net::arp_for
handle_tx_completions	xenfront.cc	/^future<> xenfront_qp::handle_tx_completions() {$/;"	f	class:xen::xenfront_qp
handshake	tls.cc	/^    future<> handshake() {$/;"	f	class:seastar::tls::session
has_next	virtio.cc	/^            uint16_t has_next : 1;$/;"	m	struct:virtio::vring::desc::flags	file:
has_room	xenfront.cc	/^future<> front_ring<T>::entries::has_room() {$/;"	f	class:xen::front_ring::entries
hash	ip.hh	/^    uint32_t hash(const rss_key_type& rss_key) {$/;"	f	struct:net::l4connid
hash	ip.hh	/^struct hash<net::ipv4_address> {$/;"	s	namespace:std
hash	ip.hh	/^struct ipv4_frag_id::hash : private std::hash<ipv4_address>,$/;"	s	class:net::ipv4_frag_id
hash2cpu	net.cc	/^unsigned interface::hash2cpu(uint32_t hash) {$/;"	f	class:net::interface
hash2cpu	net.hh	/^    virtual unsigned hash2cpu(uint32_t hash) {$/;"	f	class:net::device
hash2qid	net.hh	/^    virtual unsigned hash2qid(uint32_t hash) {$/;"	f	class:net::device
hdr_len	virtio.cc	/^        uint16_t hdr_len;$/;"	m	struct:virtio::qp::net_hdr	file:
header	ip.hh	/^        packet header;$/;"	m	struct:net::ipv4::frag
hlen	arp.hh	/^        uint8_t hlen;$/;"	m	struct:net::arp_for::arp_hdr
hlen	dhcp.cc	/^        uint8_t hlen = 6;           \/\/ Hardware address length$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
hops	dhcp.cc	/^        uint8_t hops = 0;           \/\/ Client sets to zero, used by relay agents$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
host_address	ip.cc	/^ipv4_address ipv4::host_address() {$/;"	f	class:net::ipv4
hton	byteorder.hh	/^T hton(const T& x) {$/;"	f	namespace:net
hton	byteorder.hh	/^inline T hton(const packed<T>& x) {$/;"	f	namespace:net
hton	byteorder.hh	/^inline int16_t hton(int16_t x) { return htons(x); }$/;"	f	namespace:net
hton	byteorder.hh	/^inline int32_t hton(int32_t x) { return htonl(x); }$/;"	f	namespace:net
hton	byteorder.hh	/^inline int64_t hton(int64_t x) { return htonq(x); }$/;"	f	namespace:net
hton	byteorder.hh	/^inline int8_t hton(int8_t x) { return x; }$/;"	f	namespace:net
hton	byteorder.hh	/^inline uint16_t hton(uint16_t x) { return htons(x); }$/;"	f	namespace:net
hton	byteorder.hh	/^inline uint32_t hton(uint32_t x) { return htonl(x); }$/;"	f	namespace:net
hton	byteorder.hh	/^inline uint64_t hton(uint64_t x) { return htonq(x); }$/;"	f	namespace:net
hton	byteorder.hh	/^inline uint8_t hton(uint8_t x) { return x; }$/;"	f	namespace:net
hton	byteorder.hh	/^inline void hton() {}$/;"	f	namespace:net
hton	tcp.hh	/^inline tcp_seq hton(tcp_seq s) {$/;"	f	class:net::tcp_state::tcp_option::option_kind
hton_inplace	byteorder.hh	/^void hton_inplace() {};$/;"	f	namespace:net
hton_inplace	byteorder.hh	/^void hton_inplace(First& first, Rest&... rest) {$/;"	f	namespace:net
htonq	byteorder.hh	/^inline uint64_t htonq(uint64_t v) {$/;"	f
htype	arp.hh	/^        packed<uint16_t> htype;$/;"	m	struct:net::arp::arp_hdr
htype	arp.hh	/^        packed<uint16_t> htype;$/;"	m	struct:net::arp_for::arp_hdr
htype	dhcp.cc	/^    enum class htype : uint8_t {$/;"	c	class:net::dhcp::impl::m_type	file:
hw_address	net.hh	/^    ethernet_address hw_address() { return _hw_address; }$/;"	f	class:net::interface
hw_features	ip.hh	/^    const net::hw_features& hw_features() const { return _netif->hw_features(); }$/;"	f	class:net::ipv4
hw_features	net.hh	/^    const net::hw_features& hw_features() const { return _hw_features; }$/;"	f	class:net::interface
hw_features	net.hh	/^struct hw_features {$/;"	s	namespace:net
hw_features	tcp.hh	/^    const net::hw_features& hw_features() const { return _inet._inet.hw_features(); }$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp
hw_features	virtio.cc	/^    net::hw_features hw_features() {$/;"	f	class:virtio::device
hw_features_ref	dpdk.cc	/^    net::hw_features& hw_features_ref() { return _hw_features; }$/;"	f	class:dpdk::dpdk_device
hw_queues_count	net.cc	/^uint16_t interface::hw_queues_count() {$/;"	f	class:net::interface
hw_queues_count	net.hh	/^    virtual uint16_t hw_queues_count() { return 1; }$/;"	f	class:net::device
i40e_max_xmit_segment_frags	dpdk.cc	/^static constexpr uint8_t  i40e_max_xmit_segment_frags = 8;$/;"	m	namespace:dpdk	file:
i40e_should_linearize	dpdk.cc	/^        static bool i40e_should_linearize(rte_mbuf *head) {$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
icmp	const.hh	/^    icmp = 1, tcp = 6, udp = 17, unused = 255$/;"	m	class:net::ip_protocol_num
icmp	ip.hh	/^    explicit icmp(inet_type& inet) : _inet(inet) {$/;"	f	class:net::icmp
icmp	ip.hh	/^class icmp {$/;"	c	namespace:net
icmp_hdr	ip.hh	/^struct icmp_hdr {$/;"	s	namespace:net
id	ip.hh	/^    packed<uint16_t> id;$/;"	m	struct:net::ip_hdr
id	xenfront.hh	/^    uint16_t id;$/;"	m	struct:xen::netif_rx_request
id	xenfront.hh	/^    uint16_t id;$/;"	m	struct:xen::netif_rx_response
id	xenfront.hh	/^    uint16_t id;$/;"	m	struct:xen::netif_tx_request
id	xenfront.hh	/^    uint16_t id;$/;"	m	struct:xen::netif_tx_response
identification	ip.hh	/^    uint16_t identification;$/;"	m	struct:net::ipv4_frag_id
idle	api.hh	/^    std::chrono::seconds idle; \/\/ TCP_KEEPIDLE$/;"	m	struct:seastar::net::tcp_keepalive_params
idx	xenfront.hh	/^    static uint32_t idx(int i) { return i & (nr_ents - 1); }$/;"	f	class:xen::front_ring
ihl	ip.hh	/^    uint8_t ihl : 4;$/;"	m	struct:net::ip_hdr
impl	dhcp.cc	/^    impl(ipv4 & stack)$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
impl	dhcp.cc	/^class net::dhcp::impl : public ip_packet_filter {$/;"	c	class:net::dhcp	file:
impl	packet.hh	/^    struct impl {$/;"	s	class:net::final
impl	packet.hh	/^packet::impl::impl(fragment frag, size_t nr_frags)$/;"	f	class:net::packet::impl
impl	packet.hh	/^packet::impl::impl(size_t nr_frags)$/;"	f	class:net::packet::impl
impl	tls.cc	/^    impl()$/;"	f	class:seastar::tls::certificate_credentials::impl
impl	tls.cc	/^    impl()$/;"	f	class:seastar::tls::dh_params::impl
impl	tls.cc	/^    impl()$/;"	f	class:seastar::tls::x509_cert::impl
impl	tls.cc	/^    impl(const blob& b, x509_crt_format fmt)$/;"	f	class:seastar::tls::x509_cert::impl
impl	tls.cc	/^    impl(const blob& pkcs3, x509_crt_format fmt)$/;"	f	class:seastar::tls::dh_params::impl
impl	tls.cc	/^    impl(const impl& v)$/;"	f	class:seastar::tls::dh_params::impl
impl	tls.cc	/^    impl(level lvl)$/;"	f	class:seastar::tls::dh_params::impl
impl	tls.cc	/^class seastar::tls::certificate_credentials::impl: public gnutlsobj {$/;"	c	class:seastar::tls::certificate_credentials	file:
impl	tls.cc	/^class seastar::tls::dh_params::impl : gnutlsobj {$/;"	c	class:seastar::tls::dh_params	file:
impl	tls.cc	/^class seastar::tls::x509_cert::impl : gnutlsobj {$/;"	c	class:seastar::tls::x509_cert	file:
in	api.hh	/^        ::sockaddr_in in;$/;"	m	union:socket_address::__anon2
in_avail	tls.cc	/^    size_t in_avail() const {$/;"	f	class:seastar::tls::session
in_my_netmask	ip.cc	/^bool ipv4::in_my_netmask(ipv4_address a) const {$/;"	f	class:net::ipv4
in_state	tcp.hh	/^        bool in_state(tcp_state state) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
inc_csum_err	net.hh	/^            void inc_csum_err() {$/;"	f	struct:net::qp_stats::__anon9::__anon10
inc_no_mem	net.hh	/^            void inc_no_mem() {$/;"	f	struct:net::qp_stats::__anon9::__anon10
inc_pending	tcp.hh	/^        void inc_pending() { _pending++; }$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::listener
inc_rx_error_count	xenfront.cc	/^    void inc_rx_error_count() { ++_stats.rx.bad.total; }$/;"	f	class:xen::xenfront_qp
indirect	virtio.cc	/^            uint16_t indirect : 1;$/;"	m	struct:virtio::vring::desc::flags	file:
indirect	virtio.cc	/^    bool indirect;$/;"	m	struct:virtio::ring_config	file:
init_factory	dpdk.cc	/^        void init_factory() {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory	file:
init_from_options	tcp.hh	/^void tcp<InetTraits>::tcb::init_from_options(tcp_hdr* th, uint8_t* opt_start, uint8_t* opt_end) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
init_local_queue	dpdk.cc	/^std::unique_ptr<qp> dpdk_device::init_local_queue(boost::program_options::variables_map opts, uint16_t qid) {$/;"	f	class:dpdk::dpdk_device
init_local_queue	virtio.cc	/^std::unique_ptr<net::qp> device::init_local_queue(boost::program_options::variables_map opts, uint16_t qid) {$/;"	f	class:virtio::device
init_local_queue	xenfront.cc	/^std::unique_ptr<qp> xenfront_device::init_local_queue(boost::program_options::variables_map opts, uint16_t qid) {$/;"	f	class:xen::xenfront_device
init_noninline_rx_mbuf	dpdk.cc	/^    static bool init_noninline_rx_mbuf(rte_mbuf* m,$/;"	f	class:dpdk::dpdk_qp	file:
init_port_fini	dpdk.cc	/^void dpdk_device::init_port_fini()$/;"	f	class:dpdk::dpdk_device
init_port_start	dpdk.cc	/^int dpdk_device::init_port_start()$/;"	f	class:dpdk::dpdk_device
init_rx_mbuf_pool	dpdk.cc	/^bool dpdk_qp<HugetlbfsMemBackend>::init_rx_mbuf_pool()$/;"	f	class:dpdk::dpdk_qp
initial	tcp.hh	/^            tcp_seq initial;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
initial	tcp.hh	/^            tcp_seq initial;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
initialize	api.hh	/^    virtual future<> initialize() {$/;"	f	class:seastar::network_stack
initialize	native-stack.cc	/^future<> native_network_stack::initialize() {$/;"	f	class:net::native_network_stack
inline_mbuf_data_size	dpdk.cc	/^static constexpr size_t   inline_mbuf_data_size  = 2048;$/;"	m	namespace:dpdk	file:
inline_mbuf_size	dpdk.cc	/^static constexpr uint16_t inline_mbuf_size       =$/;"	m	namespace:dpdk	file:
input	stack.cc	/^input_stream<char> connected_socket::input() {$/;"	f	class:connected_socket
input_handle_listen_state	tcp.hh	/^void tcp<InetTraits>::tcb::input_handle_listen_state(tcp_hdr* th, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
input_handle_other_state	tcp.hh	/^void tcp<InetTraits>::tcb::input_handle_other_state(tcp_hdr* th, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
input_handle_syn_sent_state	tcp.hh	/^void tcp<InetTraits>::tcb::input_handle_syn_sent_state(tcp_hdr* th, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
insert_out_of_order	tcp.hh	/^void tcp<InetTraits>::tcb::insert_out_of_order(tcp_seq seg, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
interface	net.cc	/^interface::interface(std::shared_ptr<device> dev)$/;"	f	class:net::interface
interface	net.hh	/^class interface {$/;"	c	namespace:net
internal_data_size	packet.cc	/^constexpr size_t packet::internal_data_size;$/;"	m	class:net::packet	file:
internal_data_size	packet.hh	/^    static constexpr size_t internal_data_size = 128 - 16;$/;"	m	class:net::final
interval	api.hh	/^    std::chrono::seconds interval; \/\/ TCP_KEEPINTVL$/;"	m	struct:seastar::net::tcp_keepalive_params
interval	api.hh	/^    std::chrono::seconds interval; \/\/ spp_hbinterval$/;"	m	struct:seastar::net::sctp_keepalive_params
ip	api.hh	/^    uint32_t ip;$/;"	m	struct:seastar::ipv4_addr
ip	dhcp.cc	/^        packed<uint32_t> ip;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_option	file:
ip	dhcp.hh	/^        ipv4_address ip;$/;"	m	struct:net::dhcp::lease
ip	ip.hh	/^    packed<uint32_t> ip;$/;"	m	struct:net::ipv4_address
ip_checksum	ip_checksum.cc	/^uint16_t ip_checksum(const void* data, size_t len) {$/;"	f	namespace:net
ip_hdr	ip.hh	/^struct ip_hdr {$/;"	s	namespace:net
ip_hdr_len	packet.hh	/^    uint8_t ip_hdr_len = 20;$/;"	m	struct:net::offload_info
ip_hdr_len_min	ip.hh	/^    static constexpr uint8_t ip_hdr_len_min = net::ipv4_hdr_len_min;$/;"	m	struct:net::ipv4_traits
ip_info	dhcp.cc	/^    struct ip_info : public lease {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
ip_option	dhcp.cc	/^        ip_option(opt_type t = opt_type::BROADCAST_ADDRESS, const ipv4_address & ip = ipv4_address()) : option(t, sizeof(uint32_t)), ip(htonl(ip.ip)) {}$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_option
ip_option	dhcp.cc	/^    struct ip_option : public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
ip_packet_filter	ip.hh	/^struct ip_packet_filter {$/;"	s	namespace:net
ip_packet_len_max	const.hh	/^const uint16_t ip_packet_len_max = 65535;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
ip_proto	ip.hh	/^    uint8_t ip_proto;$/;"	m	class:net::ip_hdr::frag_bits
ip_protocol	ip.hh	/^class ip_protocol {$/;"	c	namespace:net
ip_protocol_num	const.hh	/^enum class ip_protocol_num : uint8_t {$/;"	c	namespace:net
ipv4	const.hh	/^    ipv4 = 0x0800, arp = 0x0806, ipv6 = 0x86dd$/;"	m	class:net::ip_protocol_num::eth_protocol_num
ipv4	ip.cc	/^ipv4::ipv4(interface* netif)$/;"	f	class:net::ipv4
ipv4	ip.hh	/^class ipv4 {$/;"	c	namespace:net
ipv4_addr	api.hh	/^    ipv4_addr() : ip(0), port(0) {}$/;"	f	struct:seastar::ipv4_addr
ipv4_addr	api.hh	/^    ipv4_addr(const socket_address &sa) {$/;"	f	struct:seastar::ipv4_addr
ipv4_addr	api.hh	/^    ipv4_addr(socket_address &&sa) : ipv4_addr(sa) {}$/;"	f	struct:seastar::ipv4_addr
ipv4_addr	api.hh	/^    ipv4_addr(uint16_t port) : ip(0), port(port) {}$/;"	f	struct:seastar::ipv4_addr
ipv4_addr	api.hh	/^    ipv4_addr(uint32_t ip, uint16_t port) : ip(ip), port(port) {}$/;"	f	struct:seastar::ipv4_addr
ipv4_addr	api.hh	/^struct ipv4_addr {$/;"	s	namespace:seastar
ipv4_addr	net.cc	/^ipv4_addr::ipv4_addr(const std::string &addr) {$/;"	f	class:ipv4_addr
ipv4_addr	net.cc	/^ipv4_addr::ipv4_addr(const std::string &addr, uint16_t port_) : ip(boost::asio::ip::address_v4::from_string(addr).to_ulong()), port(port_) {}$/;"	f	class:ipv4_addr
ipv4_address	ip.hh	/^    explicit ipv4_address(const std::string& addr) {$/;"	f	struct:net::ipv4_address
ipv4_address	ip.hh	/^    explicit ipv4_address(uint32_t ip) : ip(ip) {}$/;"	f	struct:net::ipv4_address
ipv4_address	ip.hh	/^    ipv4_address() : ip(0) {}$/;"	f	struct:net::ipv4_address
ipv4_address	ip.hh	/^    ipv4_address(ipv4_addr addr) {$/;"	f	struct:net::ipv4_address
ipv4_address	ip.hh	/^struct ipv4_address {$/;"	s	namespace:net
ipv4_frag_id	ip.hh	/^struct ipv4_frag_id {$/;"	s	namespace:net
ipv4_hdr_len_min	const.hh	/^const uint8_t ipv4_hdr_len_min = 20;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
ipv4_icmp	ip.hh	/^    ipv4_icmp(ipv4& inet) : _inet_l4(inet), _icmp(_inet_l4) {}$/;"	f	class:net::final
ipv4_l4	ip.hh	/^    ipv4_l4(ipv4& inet) : _inet(inet) {}$/;"	f	class:net::ipv4_l4
ipv4_l4	ip.hh	/^class ipv4_l4 {$/;"	c	namespace:net
ipv4_tag	ip.hh	/^struct ipv4_tag {};$/;"	s	namespace:net
ipv4_tcp	tcp.cc	/^ipv4_tcp::ipv4_tcp(ipv4& inet)$/;"	f	class:net::ipv4_tcp
ipv4_traits	ip.hh	/^struct ipv4_traits {$/;"	s	namespace:net
ipv4_udp	ip.hh	/^class ipv4_udp : public ip_protocol {$/;"	c	namespace:net
ipv4_udp	udp.cc	/^ipv4_udp::ipv4_udp(ipv4& inet)$/;"	f	class:net::ipv4_udp
ipv4_udp_impl	udp.cc	/^namespace ipv4_udp_impl {$/;"	n	namespace:net	file:
ipv6	const.hh	/^    ipv4 = 0x0800, arp = 0x0806, ipv6 = 0x86dd$/;"	m	class:net::ip_protocol_num::eth_protocol_num
ipv6_hdr_len_min	const.hh	/^const uint8_t ipv6_hdr_len_min = 40;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
is_closed	stack.cc	/^bool net::udp_channel::is_closed() const {$/;"	f	class:net::udp_channel
is_closed	udp.cc	/^    virtual bool is_closed() const {$/;"	f	class:net::ipv4_udp_impl::native_channel
is_complete	ip.cc	/^bool ipv4::frag::is_complete() {$/;"	f	class:net::ipv4::frag
is_i40e_device	dpdk.cc	/^    bool is_i40e_device() const {$/;"	f	class:dpdk::dpdk_device
is_ip_unspecified	api.hh	/^bool is_ip_unspecified(ipv4_addr &addr) {$/;"	f	namespace:seastar
is_port_unspecified	api.hh	/^bool is_port_unspecified(ipv4_addr &addr) {$/;"	f	namespace:seastar
is_unspecified	ip.hh	/^static inline bool is_unspecified(ipv4_address addr) { return addr.ip == 0; }$/;"	f	namespace:net
is_vmxnet3_device	dpdk.cc	/^    bool is_vmxnet3_device() const {$/;"	f	class:dpdk::dpdk_device
is_xen	native-stack.cc	/^static xen_info is_xen()$/;"	f	namespace:net
isn_secret	tcp.hh	/^            isn_secret () {$/;"	f	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::isn_secret
isn_secret	tcp.hh	/^        struct isn_secret {$/;"	s	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
key	tcp.hh	/^            uint32_t key[16];$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::isn_secret
kick	virtio.cc	/^    void kick() {$/;"	f	class:virtio::vring	file:
kind	tcp.hh	/^        option_kind kind = option_kind::eol;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::eol
kind	tcp.hh	/^        option_kind kind = option_kind::mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::mss
kind	tcp.hh	/^        option_kind kind = option_kind::nop;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::nop
kind	tcp.hh	/^        option_kind kind = option_kind::sack;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::sack
kind	tcp.hh	/^        option_kind kind = option_kind::timestamps;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
kind	tcp.hh	/^        option_kind kind = option_kind::win_scale;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::win_scale
l2receive	net.hh	/^    void l2receive(packet p) { _queues[engine().cpu_id()]->_rx_stream.produce(std::move(p)); }$/;"	f	class:net::device
l2self	arp.hh	/^    ethernet_address l2self() { return _netif->hw_address(); }$/;"	f	class:net::arp
l2self	arp.hh	/^    l2addr l2self() { return _arp.l2self(); }$/;"	f	class:net::arp_for
l3_protocol	net.cc	/^l3_protocol::l3_protocol(interface* netif, eth_protocol_num proto_num, packet_provider_type func)$/;"	f	class:net::l3_protocol
l3_protocol	net.hh	/^class l3_protocol {$/;"	c	namespace:net
l3_rx_stream	net.hh	/^        l3_rx_stream(std::function<bool (forward_hash&, packet&, size_t)>&& fw) : ready(packet_stream.started()), forward(fw) {}$/;"	f	struct:net::interface::l3_rx_stream
l3_rx_stream	net.hh	/^    struct l3_rx_stream {$/;"	s	class:net::interface
l3packet	net.hh	/^    struct l3packet {$/;"	s	class:net::l3_protocol
l4connid	ip.hh	/^struct l4connid {$/;"	s	namespace:net
l4packet	ip.hh	/^    struct l4packet {$/;"	s	struct:net::ipv4_traits
last_bunch	net.hh	/^    uint64_t last_bunch; \/\/ number of packets in the last sent\/received bunch$/;"	m	struct:net::qp_stats_good
last_frag_received	ip.hh	/^        bool last_frag_received = false;$/;"	m	struct:net::ipv4::frag
learn	arp.hh	/^arp_for<L3>::learn(l2addr hwaddr, l3addr paddr) {$/;"	f	class:net::arp_for
learn	ip.hh	/^    void learn(ethernet_address l2, ipv4_address l3) {$/;"	f	class:net::ipv4
lease	dhcp.hh	/^    struct lease {$/;"	s	class:net::dhcp
lease_time	dhcp.hh	/^        std::chrono::seconds lease_time;$/;"	m	struct:net::dhcp::lease
len	dhcp.cc	/^        uint8_t len;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::option	file:
len	dpdk.cc	/^            uint64_t len;          \/\/ packets with a bad length$/;"	m	struct:dpdk::port_stats::__anon3::__anon5	file:
len	ip.hh	/^    packed<uint16_t> len;$/;"	m	struct:net::ip_hdr
len	packet.hh	/^    unsigned len() const { return _impl->_len; }$/;"	f	class:net::final
len	tcp.hh	/^        option_len len = option_len::mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::mss
len	tcp.hh	/^        option_len len = option_len::sack;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::sack
len	tcp.hh	/^        option_len len = option_len::timestamps;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
len	tcp.hh	/^        option_len len = option_len::win_scale;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::win_scale
len	udp.hh	/^    packed<uint16_t> len;$/;"	m	struct:net::udp_hdr
len	virtio.cc	/^    uint32_t len;$/;"	m	struct:virtio::buffer	file:
level	tls.hh	/^        enum class level {$/;"	c	class:seastar::tls::dh_params
limited_transfer	tcp.hh	/^            uint32_t limited_transfer = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
linearizations	packet-util.hh	/^    static uint64_t linearizations() {$/;"	f	class:net::packet_merger
linearizations_ref	packet-util.hh	/^    static uint64_t& linearizations_ref() {$/;"	f	class:net::packet_merger
linearize	packet.cc	/^void packet::linearize(size_t at_frag, size_t desired_size) {$/;"	f	class:net::packet
linearize	packet.hh	/^    void linearize() { return linearize(0, len()); }$/;"	f	class:net::final
linearized	net.hh	/^        uint64_t linearized;       \/\/ number of packets that were linearized$/;"	m	struct:net::qp_stats::__anon11
link_ready	dpdk.cc	/^    virtual future<> link_ready() { return _link_ready_promise.get_future(); }$/;"	f	class:dpdk::dpdk_device
link_ready	net.hh	/^    virtual future<> link_ready() { return make_ready_future<>(); }$/;"	f	class:net::device
listen	native-stack.cc	/^native_network_stack::listen(socket_address sa, listen_options opts) {$/;"	f	class:net::native_network_stack
listen	posix-stack.cc	/^posix_ap_network_stack::listen(socket_address sa, listen_options opt) {$/;"	f	class:net::posix_ap_network_stack
listen	posix-stack.cc	/^posix_network_stack::listen(socket_address sa, listen_options opt) {$/;"	f	class:net::posix_network_stack
listen	tls.cc	/^::server_socket seastar::tls::listen(::shared_ptr<server_credentials> creds, ::server_socket ss) {$/;"	f	class:seastar::tls
listen	tls.cc	/^::server_socket seastar::tls::listen(::shared_ptr<server_credentials> creds, ::socket_address sa, ::listen_options opts) {$/;"	f	class:seastar::tls
listen_options	api.hh	/^    listen_options(bool rua = false)$/;"	f	struct:seastar::listen_options
listen_options	api.hh	/^struct listen_options {$/;"	s	namespace:seastar
listener	tcp.hh	/^        listener(listener&& x)$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::listener
listener	tcp.hh	/^        listener(tcp& t, uint16_t port, size_t queue_length)$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::listener
listener	tcp.hh	/^    class listener {$/;"	c	class:net::tcp_state::tcp_option::option_kind::tcp
local_ip	ip.hh	/^    ipaddr local_ip;$/;"	m	struct:net::l4connid
local_mss	tcp.hh	/^        uint16_t local_mss() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
local_port	ip.hh	/^    uint16_t local_port;$/;"	m	struct:net::l4connid
local_queue	net.hh	/^    qp& local_queue() { return queue_for_cpu(engine().cpu_id()); }$/;"	f	class:net::device
log	dhcp.cc	/^    decltype(std::cout) & log() {$/;"	f	class:net::dhcp::impl
lookup	arp.hh	/^arp_for<L3>::lookup(const l3addr& paddr) {$/;"	f	class:net::arp_for
m_type	dhcp.cc	/^    enum class m_type : uint8_t {$/;"	c	class:net::dhcp::impl	file:
mac	ethernet.hh	/^    std::array<uint8_t, 6> mac;$/;"	m	struct:net::ethernet_address
magic	dhcp.cc	/^        magic_tag magic = options_magic;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_payload	file:
magic_tag	dhcp.cc	/^    typedef std::array<uint8_t, 4> magic_tag;$/;"	t	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
make_channel	udp.cc	/^ipv4_udp::make_channel(ipv4_addr addr) {$/;"	f	class:net::ipv4_udp
make_ipv4_address	api.hh	/^socket_address make_ipv4_address(ipv4_addr addr) {$/;"	f	namespace:seastar
make_query_packet	arp.hh	/^arp_for<L3>::make_query_packet(l3addr paddr) {$/;"	f	class:net::arp_for
make_seq	tcp.hh	/^inline tcp_seq make_seq(uint32_t raw) { return tcp_seq{raw}; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
make_udp_channel	native-stack.cc	/^native_network_stack::make_udp_channel(ipv4_addr addr) {$/;"	f	class:net::native_network_stack
make_udp_channel	posix-stack.cc	/^posix_network_stack::make_udp_channel(ipv4_addr addr) {$/;"	f	class:net::posix_network_stack
map	packet-util.hh	/^    std::map<Offset, packet> map;$/;"	m	class:net::packet_merger
mask	virtio.cc	/^    size_t mask() { return size() - 1; }$/;"	f	class:virtio::vring	file:
masked	virtio.cc	/^    size_t masked(size_t idx) { return idx & mask(); }$/;"	f	class:virtio::vring	file:
max_frags	dpdk.cc	/^static constexpr uint8_t  max_frags              = 32 + 1;$/;"	m	namespace:dpdk	file:
max_packet_len	net.hh	/^    uint16_t max_packet_len = net::ip_packet_len_max - net::eth_hdr_len;$/;"	m	struct:net::hw_features
max_waiters	arp.hh	/^    static constexpr auto max_waiters = 512;$/;"	m	class:net::arp_for
maybe_load_system_trust	tls.cc	/^    future<> maybe_load_system_trust() {$/;"	f	class:seastar::tls::certificate_credentials::impl	file:
maybe_rehandshake	tls.cc	/^    future<> maybe_rehandshake() {$/;"	f	class:seastar::tls::session
mbuf_cache_size	dpdk.cc	/^static constexpr uint16_t mbuf_cache_size        = 512;$/;"	m	namespace:dpdk	file:
mbuf_data_size	dpdk.cc	/^static constexpr size_t   mbuf_data_size         = 2048;$/;"	m	namespace:dpdk	file:
mbuf_overhead	dpdk.cc	/^static constexpr uint16_t mbuf_overhead          =$/;"	m	namespace:dpdk	file:
mbufs_per_queue_rx	dpdk.cc	/^static constexpr uint16_t mbufs_per_queue_rx     = 2 * default_ring_size;$/;"	m	namespace:dpdk	file:
mbufs_per_queue_tx	dpdk.cc	/^static constexpr uint16_t mbufs_per_queue_tx     = 2 * default_ring_size;$/;"	m	namespace:dpdk	file:
mcast	dpdk.cc	/^            uint64_t mcast;        \/\/ number of received multicast packets$/;"	m	struct:dpdk::port_stats::__anon3::__anon4	file:
me	dpdk.cc	/^        static tx_buf* me(rte_mbuf* mbuf) {$/;"	f	class:dpdk::dpdk_qp::tx_buf
mem_size	ip.hh	/^        uint32_t mem_size = 0;$/;"	m	struct:net::ipv4::frag
memory	packet.hh	/^    unsigned memory() const { return len() +  sizeof(packet::impl); }$/;"	f	class:net::final
mergable_buffers	virtio.cc	/^    bool mergable_buffers;$/;"	m	struct:virtio::ring_config	file:
merge	ip.cc	/^int32_t ipv4::frag::merge(ip_hdr &h, uint16_t offset, packet p) {$/;"	f	class:net::ipv4::frag
merge	packet-util.hh	/^    void merge(Offset offset, packet p) {$/;"	f	class:net::packet_merger
merge_out_of_order	tcp.hh	/^bool tcp<InetTraits>::tcb::merge_out_of_order() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
message	tls.cc	/^    std::string message(int error) const {$/;"	f	class:gnutls_error_category
mf	ip.hh	/^    bool mf() { return frag & (1 << uint8_t(frag_bits::mf)); }$/;"	f	class:net::ip_hdr::frag_bits
mf	ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	m	class:net::ip_hdr::frag_bits
min_anonymous_port	ip.hh	/^    static const uint16_t min_anonymous_port = 32768;$/;"	m	class:net::ipv4_udp
more_data	xenfront.hh	/^        uint16_t more_data : 1;$/;"	m	struct:xen::netif_tx_request::__anon14
move	packet.hh	/^    : _impl(std::move(x._impl)) {$/;"	f	namespace:net
move	tcp.hh	/^        connection(connection&& x) noexcept : _tcb(std::move(x._tcb)) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
move_connected_socket	posix-stack.cc	/^void  posix_ap_server_socket_impl<Transport>::move_connected_socket(socket_address sa, pollable_fd fd, socket_address addr) {$/;"	f	class:net::posix_ap_server_socket_impl
msg_type	dhcp.cc	/^    enum class msg_type : uint8_t {$/;"	c	class:net::dhcp::impl::m_type::htype::opt_type	file:
msg_type	ip.hh	/^    enum class msg_type : uint8_t {$/;"	c	struct:net::icmp_hdr
mss	tcp.hh	/^            uint16_t mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
mss	tcp.hh	/^            uint16_t mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
mss	tcp.hh	/^        packed<uint16_t> mss;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::mss
mss	tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
mss	tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
mss	tcp.hh	/^    struct mss {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
mtu	dhcp.cc	/^        packed<uint16_t> mtu;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::mtu_option	file:
mtu	dhcp.hh	/^        uint16_t mtu = 0;$/;"	m	struct:net::dhcp::lease
mtu	net.hh	/^    uint16_t mtu = 1500;$/;"	m	struct:net::hw_features
mtu_option	dhcp.cc	/^        mtu_option(uint16_t v) : option(opt_type::INTERFACE_MTU, 2), mtu((::htons)(v)) {}$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::mtu_option
mtu_option	dhcp.cc	/^    struct mtu_option : public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
name_servers	dhcp.hh	/^        std::vector<ipv4_address> name_servers;$/;"	m	struct:net::dhcp::lease
native_channel	udp.cc	/^    native_channel(ipv4_udp &proto, ipv4_udp::registration reg, lw_shared_ptr<udp_channel_state> state)$/;"	f	class:net::ipv4_udp_impl::native_channel
native_channel	udp.cc	/^class native_channel : public udp_channel_impl {$/;"	c	namespace:net::ipv4_udp_impl	file:
native_connected_socket_impl	native-stack-impl.hh	/^    explicit native_connected_socket_impl(lw_shared_ptr<typename Protocol::connection> conn)$/;"	f	class:net::native_connected_socket_impl
native_connected_socket_impl	native-stack-impl.hh	/^class native_connected_socket_impl : public connected_socket_impl {$/;"	c	namespace:net
native_data_sink_impl	native-stack-impl.hh	/^    explicit native_data_sink_impl(typename Protocol::connection& conn)$/;"	f	class:net::final
native_data_source_impl	native-stack-impl.hh	/^    explicit native_data_source_impl(typename Protocol::connection& conn)$/;"	f	class:net::final
native_datagram	udp.cc	/^    native_datagram(ipv4_address src, ipv4_address dst, packet p)$/;"	f	class:net::ipv4_udp_impl::native_datagram
native_datagram	udp.cc	/^class native_datagram : public udp_datagram_impl {$/;"	c	namespace:net::ipv4_udp_impl	file:
native_network_stack	native-stack.cc	/^class native_network_stack : public network_stack {$/;"	c	namespace:net	file:
native_network_stack	native-stack.cc	/^native_network_stack::native_network_stack(boost::program_options::variables_map opts, std::shared_ptr<device> dev)$/;"	f	class:net::native_network_stack
native_server_socket_impl	native-stack-impl.hh	/^class native_server_socket_impl : public server_socket_impl {$/;"	c	namespace:net
native_server_socket_impl	native-stack-impl.hh	/^native_server_socket_impl<Protocol>::native_server_socket_impl(Protocol& proto, uint16_t port, listen_options opt)$/;"	f	class:net::native_server_socket_impl
native_socket_impl	native-stack-impl.hh	/^    explicit native_socket_impl(Protocol& proto)$/;"	f	class:net::final
need_load_system_trust	tls.cc	/^    bool need_load_system_trust() const {$/;"	f	class:seastar::tls::certificate_credentials::impl	file:
needs_csum	packet.hh	/^    bool needs_csum = false;$/;"	m	struct:net::offload_info
needs_csum	virtio.cc	/^        uint8_t needs_csum : 1;$/;"	m	struct:virtio::qp::net_hdr	file:
needs_frag	ip.cc	/^bool ipv4::needs_frag(packet& p, ip_protocol_num prot_num, net::hw_features hw_features) {$/;"	f	class:net::ipv4
needs_ip_csum	packet.hh	/^    bool needs_ip_csum = false;$/;"	m	struct:net::offload_info
net	api.hh	/^namespace net {$/;"	n	namespace:seastar
net	arp.cc	/^namespace net {$/;"	n	file:
net	arp.hh	/^namespace net {$/;"	n
net	byteorder.hh	/^namespace net {$/;"	n
net	const.hh	/^namespace net {$/;"	n
net	dhcp.hh	/^namespace net {$/;"	n
net	ethernet.cc	/^namespace net {$/;"	n	file:
net	ethernet.hh	/^namespace net {$/;"	n
net	ip.cc	/^namespace net {$/;"	n	file:
net	ip.hh	/^namespace net {$/;"	n
net	ip_checksum.cc	/^namespace net {$/;"	n	file:
net	ip_checksum.hh	/^namespace net {$/;"	n
net	native-stack-impl.hh	/^namespace net {$/;"	n
net	native-stack.cc	/^namespace net {$/;"	n	file:
net	native-stack.hh	/^namespace net {$/;"	n
net	net.cc	/^namespace net {$/;"	n	file:
net	net.hh	/^namespace net {$/;"	n
net	packet-data-source.hh	/^namespace net {$/;"	n
net	packet-util.hh	/^namespace net {$/;"	n
net	packet.cc	/^namespace net {$/;"	n	file:
net	packet.hh	/^namespace net {$/;"	n
net	posix-stack.cc	/^namespace net {$/;"	n	file:
net	posix-stack.hh	/^namespace net {$/;"	n
net	proxy.cc	/^namespace net {$/;"	n	file:
net	proxy.hh	/^namespace net {$/;"	n
net	stack.hh	/^namespace net {$/;"	n
net	tcp-stack.hh	/^namespace net {$/;"	n
net	tcp.cc	/^namespace net {$/;"	n	file:
net	tcp.hh	/^namespace net {$/;"	n
net	udp.cc	/^namespace net {$/;"	n	file:
net	udp.hh	/^namespace net {$/;"	n
net_hdr	virtio.cc	/^    struct net_hdr {$/;"	s	class:virtio::qp	file:
net_hdr_mrg	virtio.cc	/^    struct net_hdr_mrg : net_hdr {$/;"	s	class:virtio::qp	file:
netif	ip.hh	/^    interface * netif() const {$/;"	f	class:net::ipv4
netif_rx_request	xenfront.hh	/^struct netif_rx_request {$/;"	s	namespace:xen
netif_rx_response	xenfront.hh	/^struct netif_rx_response {$/;"	s	namespace:xen
netif_tx_request	xenfront.hh	/^struct netif_tx_request {$/;"	s	namespace:xen
netif_tx_response	xenfront.hh	/^struct netif_tx_response {$/;"	s	namespace:xen
netmask	dhcp.hh	/^        ipv4_address netmask;$/;"	m	struct:net::dhcp::lease
netmask_address	ip.cc	/^ipv4_address ipv4::netmask_address() const {$/;"	f	class:net::ipv4
network_stack	api.hh	/^class network_stack {$/;"	c	namespace:seastar
next	tcp.hh	/^            tcp_seq next;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
next	tcp.hh	/^            tcp_seq next;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
next_idx	virtio.cc	/^        uint16_t next_idx() { return _next; }$/;"	f	class:virtio::vring::desc
next_port	udp.cc	/^uint16_t ipv4_udp::next_port(uint16_t port) {$/;"	f	class:net::ipv4_udp
nns_options	native-stack.cc	/^boost::program_options::options_description nns_options() {$/;"	f	namespace:net
no_interrupts	virtio.cc	/^            uint16_t no_interrupts : 1;$/;"	m	struct:virtio::vring::avail_layout::flags	file:
no_mem	net.hh	/^            uint64_t no_mem;       \/\/ Packets dropped due to allocation failure$/;"	m	struct:net::qp_stats::__anon9::__anon10
no_notify	virtio.cc	/^            no_notify = 1$/;"	e	enum:virtio::vring::used_layout::__anon12	file:
noexcept	api.hh	/^    connected_socket& operator=(connected_socket&& cs) noexcept;$/;"	m	class:seastar::connected_socket
noexcept	api.hh	/^    connected_socket(connected_socket&& cs) noexcept;$/;"	m	class:seastar::connected_socket
noexcept	api.hh	/^    seastar::socket& operator=(seastar::socket&&) noexcept;$/;"	m	class:seastar::seastar::socket
noexcept	api.hh	/^    server_socket& operator=(server_socket&& cs) noexcept;$/;"	m	class:seastar::server_socket
noexcept	api.hh	/^    server_socket(server_socket&& ss) noexcept;$/;"	m	class:seastar::server_socket
noexcept	api.hh	/^    socket(socket&&) noexcept;$/;"	m	class:seastar::seastar::socket
noexcept	packet.hh	/^    packet(packet&& x) noexcept;$/;"	m	class:net::final
noexcept	tls.hh	/^        certificate_credentials& operator=(certificate_credentials&&) noexcept;$/;"	m	class:seastar::tls::dh_params::certificate_credentials
noexcept	tls.hh	/^        certificate_credentials(certificate_credentials&&) noexcept;$/;"	m	class:seastar::tls::dh_params::certificate_credentials
noexcept	tls.hh	/^        dh_params& operator=(dh_params&&) noexcept;$/;"	m	class:seastar::tls::dh_params::level
noexcept	tls.hh	/^        dh_params(dh_params&&) noexcept;$/;"	m	class:seastar::tls::dh_params::level
noexcept	tls.hh	/^        server_credentials& operator=(server_credentials&&) noexcept;$/;"	m	class:seastar::tls::dh_params::server_credentials
noexcept	tls.hh	/^        server_credentials(server_credentials&&) noexcept;$/;"	m	class:seastar::tls::dh_params::server_credentials
nonxen	native-stack.cc	/^    nonxen = 0,$/;"	m	class:net::xen_info	file:
nop	tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
nop	tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
nop	tcp.hh	/^    struct nop {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
notifications_disabled	virtio.cc	/^    bool notifications_disabled() {$/;"	f	class:virtio::vring	file:
notifier	virtio.cc	/^class notifier {$/;"	c	namespace:virtio	file:
notifier_osv	virtio.cc	/^    notifier_osv(osv::assigned_virtio &virtio, uint16_t q_index)$/;"	f	class:virtio::notifier_osv
notifier_osv	virtio.cc	/^class notifier_osv : public notifier {$/;"	c	namespace:virtio	file:
notifier_vhost	virtio.cc	/^    notifier_vhost(writeable_eventfd &&kick)$/;"	f	class:virtio::notifier_vhost
notifier_vhost	virtio.cc	/^class notifier_vhost : public notifier {$/;"	c	namespace:virtio	file:
nr_ents	xenfront.hh	/^    static constexpr uint32_t nr_ents = 256; \/* FIXME : DYN *\/$/;"	m	class:xen::front_ring
nr_frags	net.hh	/^    uint64_t nr_frags;   \/\/ total number of fragments$/;"	m	struct:net::qp_stats_good
nr_frags	packet.hh	/^    unsigned nr_frags() const { return _impl->_nr_frags; }$/;"	f	class:net::final
nr_transmits	tcp.hh	/^            unsigned nr_transmits;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::unacked_segment
ntoh	byteorder.hh	/^T ntoh(const T& x) {$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline T ntoh(const packed<T>& x) {$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline int16_t ntoh(int16_t x) { return ntohs(x); }$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline int32_t ntoh(int32_t x) { return ntohl(x); }$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline int64_t ntoh(int64_t x) { return ntohq(x); }$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline int8_t ntoh(int8_t x) { return x; }$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline uint16_t ntoh(uint16_t x) { return ntohs(x); }$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline uint32_t ntoh(uint32_t x) { return ntohl(x); }$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline uint64_t ntoh(uint64_t x) { return ntohq(x); }$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline uint8_t ntoh(uint8_t x) { return x; }$/;"	f	namespace:net
ntoh	byteorder.hh	/^inline void ntoh() {}$/;"	f	namespace:net
ntoh	tcp.hh	/^inline tcp_seq ntoh(tcp_seq s) {$/;"	f	class:net::tcp_state::tcp_option::option_kind
ntoh_inplace	byteorder.hh	/^void ntoh_inplace() {}$/;"	f	namespace:net
ntoh_inplace	byteorder.hh	/^void ntoh_inplace(First& first, Rest&... rest) {$/;"	f	namespace:net
ntohq	byteorder.hh	/^inline uint64_t ntohq(uint64_t v) {$/;"	f
num_buffers	virtio.cc	/^        uint16_t num_buffers;$/;"	m	struct:virtio::qp::net_hdr_mrg	file:
odd	ip_checksum.hh	/^    bool odd = false;$/;"	m	struct:net::checksummer
offload_info	packet.hh	/^    class offload_info offload_info() const { return _impl->_offload_info; }$/;"	f	class:net::final
offload_info	packet.hh	/^struct offload_info {$/;"	s	namespace:net
offload_info_ref	packet.hh	/^    class offload_info& offload_info_ref() { return _impl->_offload_info; }$/;"	f	class:net::final
offset	ip.hh	/^    uint16_t offset() { return frag << uint8_t(frag_bits::offset_shift); }$/;"	f	class:net::ip_hdr::frag_bits
offset	xenfront.hh	/^    uint16_t offset;       \/* Offset in page of start of received packet  *\/$/;"	m	struct:xen::netif_rx_response
offset	xenfront.hh	/^    uint16_t offset;$/;"	m	struct:xen::netif_tx_request
offset_shift	ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	m	class:net::ip_hdr::frag_bits
on_dhcp	native-stack.cc	/^void native_network_stack::on_dhcp(bool success, const dhcp::lease & res, bool is_renew) {$/;"	f	class:net::native_network_stack
op	dhcp.cc	/^        m_type op = m_type::BOOTREQUEST; \/\/ Message op code \/ message type.$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
op_reply	arp.hh	/^        op_reply = 2,$/;"	e	enum:net::arp_for::oper
op_request	arp.hh	/^        op_request = 1,$/;"	e	enum:net::arp_for::oper
oper	arp.hh	/^        packed<uint16_t> oper;$/;"	m	struct:net::arp_for::arp_hdr
oper	arp.hh	/^    enum oper {$/;"	g	class:net::arp_for
operator !=	ip.hh	/^    friend bool operator!=(ipv4_address x, ipv4_address y) {$/;"	f	struct:net::ipv4_address
operator !=	tcp.hh	/^inline bool operator!=(tcp_seq s, tcp_seq q) { return !(s == q); }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator ()	ip.hh	/^    size_t operator()(net::ipv4_address a) const { return a.ip; }$/;"	f	struct:std::hash
operator ()	virtio.cc	/^            void operator()(packet_as_buffer_chain&& bc, size_t len) {$/;"	f	struct:virtio::qp::txq::complete
operator ()	virtio.cc	/^            void operator()(single_buffer&& bc, size_t len) {$/;"	f	struct:virtio::qp::rxq::complete
operator +	tcp.hh	/^inline tcp_seq operator+(tcp_seq s, int32_t n) { return s += n; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator +=	tcp.hh	/^inline tcp_seq& operator+=(tcp_seq& s, int32_t n) { s.raw += n; return s; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator +=	tcp.hh	/^inline uint8_t& operator+=(uint8_t& x, tcp_option::option_len len) { x += uint8_t(len); return x; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator +=	tcp.hh	/^inline uint8_t*& operator+=(uint8_t*& x, tcp_option::option_len len) { x += uint8_t(len); return x; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator -	tcp.hh	/^inline int32_t operator-(tcp_seq s, tcp_seq q) { return s.raw - q.raw; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator -	tcp.hh	/^inline tcp_seq operator-(tcp_seq s, int32_t n) { return s -= n; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator -=	tcp.hh	/^inline tcp_seq& operator-=(tcp_seq& s, int32_t n) { s.raw -= n; return s; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator <	tcp.hh	/^inline bool operator<(tcp_seq s, tcp_seq q) { return s - q < 0; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator <<	api.hh	/^std::ostream& operator<<(std::ostream &os, ipv4_addr addr) {$/;"	f	namespace:seastar
operator <<	byteorder.hh	/^inline std::ostream& operator<<(std::ostream& os, const packed<T>& v) {$/;"	f	namespace:net
operator <<	ethernet.cc	/^std::ostream& operator<<(std::ostream& os, ethernet_address ea) {$/;"	f	namespace:net
operator <<	ip.cc	/^std::ostream& operator<<(std::ostream& os, ipv4_address a) {$/;"	f	namespace:net
operator <<	packet.cc	/^std::ostream& operator<<(std::ostream& os, const packet& p) {$/;"	f	namespace:net
operator <<	tcp.hh	/^std::ostream& operator<<(std::ostream& os, tcp_seq s) {$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator <=	tcp.hh	/^inline bool operator<=(tcp_seq s, tcp_seq q) { return !(s > q); }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator =	packet.hh	/^    packet& operator=(packet&& x) {$/;"	f	class:net::final
operator =	tcp.hh	/^        connection& operator=(connection&& x) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
operator ==	ip.hh	/^    bool operator==(const ipv4_frag_id& x) const {$/;"	f	struct:net::ipv4_frag_id
operator ==	ip.hh	/^    bool operator==(const l4connid& x) const {$/;"	f	struct:net::l4connid
operator ==	ip.hh	/^    friend bool operator==(ipv4_address x, ipv4_address y) {$/;"	f	struct:net::ipv4_address
operator ==	tcp.hh	/^inline bool operator==(tcp_seq s, tcp_seq q)  { return s.raw == q.raw; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator >	tcp.hh	/^inline bool operator>(tcp_seq s, tcp_seq q) { return q < s; }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator >=	tcp.hh	/^inline bool operator>=(tcp_seq s, tcp_seq q) { return !(s < q); }$/;"	f	class:net::tcp_state::tcp_option::option_kind
operator []	net.hh	/^    const uint8_t& operator[](size_t idx) const {$/;"	f	class:net::forward_hash
operator []	packet.hh	/^        fragment& operator[](size_t idx) { return _start[idx]; }$/;"	f	struct:net::final::pseudo_vector
operator []	xenfront.hh	/^        gntref& operator[](std::size_t i) { return _entries[_ring->idx(i)]; }$/;"	f	class:xen::front_ring::entries
operator []	xenfront.hh	/^    T& operator[](std::size_t i) { return _sring->_ring[idx(i)]; }$/;"	f	class:xen::front_ring
operator delete	packet.hh	/^        void operator delete(void* ptr) {$/;"	f	struct:net::final::impl
operator delete	packet.hh	/^        void operator delete(void* ptr, size_t nr_frags) {$/;"	f	struct:net::final::impl
operator gnutls_certificate_credentials_t	tls.cc	/^    operator gnutls_certificate_credentials_t() const {$/;"	f	class:seastar::tls::certificate_credentials::impl
operator gnutls_dh_params_t	tls.cc	/^    operator gnutls_dh_params_t() const {$/;"	f	class:seastar::tls::dh_params::impl
operator gnutls_session_t	tls.cc	/^    operator gnutls_session_t() const {$/;"	f	class:seastar::tls::session
operator gnutls_x509_crt_t	tls.cc	/^    operator gnutls_x509_crt_t() const {$/;"	f	class:seastar::tls::x509_cert::impl
operator new	packet.hh	/^        void* operator new(size_t size, size_t nr_frags = default_nr_frags) {$/;"	f	struct:net::final::impl
operator |	tcp.hh	/^inline tcp_state operator|(tcp_state s1, tcp_state s2) {$/;"	f	class:net::tcp_state
opt_type	dhcp.cc	/^    enum class opt_type : uint8_t {$/;"	c	class:net::dhcp::impl::m_type::htype	file:
option	dhcp.cc	/^        option(opt_type t, uint8_t l = 1) : option_mark(t), len(l) {};$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::option
option	dhcp.cc	/^    struct option : public option_mark {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
option_kind	tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	c	struct:net::tcp_state::tcp_option
option_len	tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	c	class:net::tcp_state::tcp_option::option_kind
option_mark	dhcp.cc	/^        option_mark(opt_type t = opt_type::END) : type(t) {};$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::option_mark
option_mark	dhcp.cc	/^    struct option_mark {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
options	ip.hh	/^    uint8_t options[0];$/;"	m	class:net::ip_hdr::frag_bits
options_magic	dhcp.cc	/^    static const magic_tag options_magic;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
options_magic	dhcp.cc	/^const net::dhcp::impl::magic_tag net::dhcp::impl::options_magic = { { 0x63, 0x82, 0x53,$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp::impl	file:
osv	native-stack.cc	/^    osv = 2,$/;"	m	class:net::xen_info	file:
out_of_order	tcp.hh	/^            tcp_packet_merger out_of_order;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
output	stack.cc	/^output_stream<char> connected_socket::output(size_t buffer_size) {$/;"	f	class:connected_socket
output	tcp.hh	/^        void output() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
output_one	tcp.hh	/^void tcp<InetTraits>::tcb::output_one(bool data_retransmit) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
override	arp.hh	/^    virtual future<> received(packet p) override;$/;"	m	class:net::arp_for
override	dpdk.cc	/^    virtual std::unique_ptr<qp> init_local_queue(boost::program_options::variables_map opts, uint16_t qid) override;$/;"	m	class:dpdk::dpdk_device	file:
override	dpdk.cc	/^    virtual void rx_start() override;$/;"	m	class:dpdk::dpdk_qp	file:
override	ip.hh	/^    bool forward(forward_hash& out_hash_data, packet& p, size_t off) override;$/;"	m	class:net::ipv4_udp
override	ip.hh	/^    virtual bool forward(forward_hash& out_hash_data, packet& p, size_t off) override;$/;"	m	class:net::final
override	ip.hh	/^    virtual void received(packet p, ipv4_address from, ipv4_address to) override;$/;"	m	class:net::ipv4_udp
override	native-stack-impl.hh	/^    bool get_keepalive() const override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    keepalive_params get_keepalive_parameters() const override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    virtual bool get_nodelay() const override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    virtual data_sink sink() override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    virtual data_source source() override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    virtual future<> shutdown_input() override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    virtual future<> shutdown_output() override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    virtual future<connected_socket, socket_address> accept() override;$/;"	m	class:net::native_server_socket_impl
override	native-stack-impl.hh	/^    virtual void abort_accept() override;$/;"	m	class:net::native_server_socket_impl
override	native-stack-impl.hh	/^    virtual void set_nodelay(bool nodelay) override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    void set_keepalive(bool keepalive) override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack-impl.hh	/^    void set_keepalive_parameters(const keepalive_params&) override;$/;"	m	class:net::native_connected_socket_impl
override	native-stack.cc	/^    virtual ::seastar::socket socket() override;$/;"	m	class:net::native_network_stack	file:
override	native-stack.cc	/^    virtual future<> initialize() override;$/;"	m	class:net::native_network_stack	file:
override	native-stack.cc	/^    virtual server_socket listen(socket_address sa, listen_options opt) override;$/;"	m	class:net::native_network_stack	file:
override	native-stack.cc	/^    virtual udp_channel make_udp_channel(ipv4_addr addr) override;$/;"	m	class:net::native_network_stack	file:
override	posix-stack.cc	/^    virtual future<udp_datagram> receive() override;$/;"	m	class:net::posix_udp_channel	file:
override	posix-stack.hh	/^    future<> put(packet p) override;$/;"	m	class:net::posix_data_sink_impl
override	posix-stack.hh	/^    future<> put(temporary_buffer<char> buf) override;$/;"	m	class:net::posix_data_sink_impl
override	posix-stack.hh	/^    virtual ::seastar::socket socket() override;$/;"	m	class:net::posix_network_stack
override	posix-stack.hh	/^    virtual future<connected_socket, socket_address> accept() override;$/;"	m	class:net::posix_ap_server_socket_impl
override	posix-stack.hh	/^    virtual future<temporary_buffer<char>> get() override;$/;"	m	class:net::final
override	posix-stack.hh	/^    virtual net::udp_channel make_udp_channel(ipv4_addr addr) override;$/;"	m	class:net::posix_network_stack
override	posix-stack.hh	/^    virtual server_socket listen(socket_address sa, listen_options opts) override;$/;"	m	class:net::posix_ap_network_stack
override	posix-stack.hh	/^    virtual server_socket listen(socket_address sa, listen_options opts) override;$/;"	m	class:net::posix_network_stack
override	posix-stack.hh	/^    virtual void abort_accept() override;$/;"	m	class:net::posix_ap_server_socket_impl
override	posix-stack.hh	/^    virtual void abort_accept() override;$/;"	m	class:net::posix_reuseport_server_socket_impl
override	posix-stack.hh	/^    virtual void abort_accept() override;$/;"	m	class:net::posix_server_socket_impl
override	proxy.cc	/^    virtual uint32_t send(circular_buffer<packet>& p) override;$/;"	m	class:net::proxy_net_device	file:
override	tls.cc	/^    data_sink sink() override;$/;"	m	class:seastar::tls::session	file:
override	tls.cc	/^    data_source source() override;$/;"	m	class:seastar::tls::session	file:
override	tls.hh	/^        void set_simple_pkcs12(const blob&, x509_crt_format, const sstring& password) override;$/;"	m	class:seastar::tls::dh_params::certificate_credentials
override	tls.hh	/^        void set_simple_pkcs12(const blob&, x509_crt_format, const sstring& password) override;$/;"	m	class:seastar::tls::dh_params::credentials_builder
override	tls.hh	/^        void set_x509_crl(const blob&, x509_crt_format) override;$/;"	m	class:seastar::tls::dh_params::certificate_credentials
override	tls.hh	/^        void set_x509_crl(const blob&, x509_crt_format) override;$/;"	m	class:seastar::tls::dh_params::credentials_builder
override	tls.hh	/^        void set_x509_key(const blob& cert, const blob& key, x509_crt_format) override;$/;"	m	class:seastar::tls::dh_params::certificate_credentials
override	tls.hh	/^        void set_x509_key(const blob& cert, const blob& key, x509_crt_format) override;$/;"	m	class:seastar::tls::dh_params::credentials_builder
override	tls.hh	/^        void set_x509_trust(const blob&, x509_crt_format) override ;$/;"	m	class:seastar::tls::dh_params::credentials_builder
override	tls.hh	/^        void set_x509_trust(const blob&, x509_crt_format) override;$/;"	m	class:seastar::tls::dh_params::certificate_credentials
override	virtio.cc	/^    virtual std::unique_ptr<net::qp> init_local_queue(boost::program_options::variables_map opts, uint16_t qid) override;$/;"	m	class:virtio::device	file:
override	virtio.cc	/^    virtual uint32_t send(circular_buffer<packet>& p) override;$/;"	m	class:virtio::qp	file:
override	virtio.cc	/^    virtual void rx_start() override;$/;"	m	class:virtio::qp	file:
override	xenfront.cc	/^    virtual future<> send(packet p) override;$/;"	m	class:xen::xenfront_qp	file:
override	xenfront.cc	/^    virtual std::unique_ptr<qp> init_local_queue(boost::program_options::variables_map opts, uint16_t qid) override;$/;"	m	class:xen::xenfront_device	file:
override	xenfront.cc	/^    virtual void rx_start() override;$/;"	m	class:xen::xenfront_qp	file:
p	ip.hh	/^        packet p;$/;"	m	struct:net::ipv4_traits::l4packet
p	net.hh	/^        packet p;$/;"	m	struct:net::l3_protocol::l3packet
p	tcp.hh	/^            packet p;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::unacked_segment
p	virtio.cc	/^            packet p;$/;"	m	struct:virtio::qp::txq::packet_as_buffer_chain	file:
packet	packet.hh	/^    packet(std::unique_ptr<impl>&& impl) : _impl(std::move(impl)) {}$/;"	f	class:net::final
packet	packet.hh	/^packet::packet()$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(Iterator begin, Iterator end, deleter del) {$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(const char* data, size_t size) : packet(fragment{const_cast<char*>(data), size}) {$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(fragment frag) : _impl(new impl(frag)) {$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(fragment frag, deleter d)$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(fragment frag, packet&& x)$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(packet&& x, deleter d)$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(packet&& x, fragment frag)$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(packet&& x, fragment frag, deleter d)$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(packet&& x, temporary_buffer<char> buf)$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(size_t nr_frags)$/;"	f	class:net::packet
packet	packet.hh	/^packet::packet(std::vector<fragment> frag, deleter d)$/;"	f	class:net::packet
packet_as_buffer_chain	virtio.cc	/^        struct packet_as_buffer_chain {$/;"	s	class:virtio::qp::txq	file:
packet_data_source	packet-data-source.hh	/^    explicit packet_data_source(net::packet&& p)$/;"	f	class:net::final
packet_filter	ip.cc	/^ip_packet_filter * ipv4::packet_filter() const {$/;"	f	class:net::ipv4
packet_merger	packet-util.hh	/^class packet_merger {$/;"	c	namespace:net
packet_read_size	dpdk.cc	/^static constexpr uint8_t packet_read_size        = 32;$/;"	m	namespace:dpdk	file:
packet_stream	net.hh	/^        stream<packet, ethernet_address> packet_stream;$/;"	m	struct:net::interface::l3_rx_stream
packets	net.hh	/^    uint64_t packets;    \/\/ total number of packets$/;"	m	struct:net::qp_stats_good
pad	xenfront.hh	/^        uint16_t pad : 12;$/;"	m	struct:xen::netif_tx_request::__anon14
pad	xenfront.hh	/^    uint8_t  pad[48] = { 0 };$/;"	m	class:xen::sring
page_mask	dpdk.cc	/^    static constexpr phys_addr_t page_mask = ~(memory::page_size - 1);$/;"	m	class:dpdk::dpdk_qp	file:
parse	tcp.cc	/^void tcp_option::parse(uint8_t* beg, uint8_t* end) {$/;"	f	class:net::tcp_option
parse_ethernet_address	ethernet.cc	/^ethernet_address parse_ethernet_address(std::string addr)$/;"	f	namespace:net
parse_options	dhcp.cc	/^        void parse_options(packet & p, size_t off) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_info
partial_ack	tcp.hh	/^            uint32_t partial_ack = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
path	xenfront.cc	/^    std::string path(std::string s) { return _dev->path(s); }$/;"	f	class:xen::xenfront_qp	file:
path	xenfront.cc	/^    std::string path(std::string s) { return _device_str + "\/" + s; }$/;"	f	class:xen::xenfront_device
pause_xoff	dpdk.cc	/^            uint64_t pause_xoff;   \/\/ number of received PAUSE XOFF frames$/;"	m	struct:dpdk::port_stats::__anon3::__anon4	file:
pause_xoff	dpdk.cc	/^            uint64_t pause_xoff;  \/\/ number of sent PAUSE XOFF frames$/;"	m	struct:dpdk::port_stats::__anon6::__anon7	file:
pause_xon	dpdk.cc	/^            uint64_t pause_xon;    \/\/ number of received PAUSE XON frames$/;"	m	struct:dpdk::port_stats::__anon3::__anon4	file:
pause_xon	dpdk.cc	/^            uint64_t pause_xon;   \/\/ number of sent PAUSE XON frames$/;"	m	struct:dpdk::port_stats::__anon6::__anon7	file:
persist	tcp.hh	/^void tcp<InetTraits>::tcb::persist() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
pkcs12_key	tls.cc	/^static const sstring pkcs12_key = "pkcs12";$/;"	v	file:
pktinfo	posix-stack.cc	/^    struct in_pktinfo pktinfo;$/;"	m	struct:net::cmsg_with_pktinfo	typeref:struct:net::cmsg_with_pktinfo::in_pktinfo	file:
pktmbuf_pool_name	dpdk.cc	/^static constexpr const char* pktmbuf_pool_name   = "dpdk_net_pktmbuf_pool";$/;"	m	namespace:dpdk	file:
plen	arp.hh	/^        uint8_t plen;$/;"	m	struct:net::arp_for::arp_hdr
poll_rx_once	dpdk.cc	/^bool dpdk_qp<HugetlbfsMemBackend>::poll_rx_once()$/;"	f	class:dpdk::dpdk_qp
poll_tcb	tcp.hh	/^future<> tcp<InetTraits>::poll_tcb(ipaddr to, lw_shared_ptr<tcb> tcb) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp
poll_tx	net.cc	/^bool qp::poll_tx() {$/;"	f	class:net::qp
port	api.hh	/^    uint16_t port;$/;"	m	struct:seastar::ipv4_addr
port	dpdk.cc	/^    dpdk_device& port() const { return *_dev; }$/;"	f	class:dpdk::dpdk_qp
port	ip.hh	/^        uint16_t port() const {$/;"	f	class:net::ipv4_udp::registration
port_idx	dpdk.cc	/^    uint8_t port_idx() { return _port_idx; }$/;"	f	class:dpdk::dpdk_device
port_stats	dpdk.cc	/^    port_stats() : rx{}, tx{} {}$/;"	f	struct:dpdk::port_stats
port_stats	dpdk.cc	/^struct port_stats {$/;"	s	namespace:dpdk	file:
posix_ap_network_stack	posix-stack.hh	/^    posix_ap_network_stack(boost::program_options::variables_map opts) : posix_network_stack(std::move(opts)), _reuseport(engine().posix_reuseport_available()) {}$/;"	f	class:net::posix_ap_network_stack
posix_ap_network_stack	posix-stack.hh	/^class posix_ap_network_stack : public posix_network_stack {$/;"	c	namespace:net
posix_ap_server_socket_impl	posix-stack.hh	/^    explicit posix_ap_server_socket_impl(socket_address sa) : _sa(sa) {}$/;"	f	class:net::posix_ap_server_socket_impl
posix_ap_server_socket_impl	posix-stack.hh	/^class posix_ap_server_socket_impl : public server_socket_impl {$/;"	c	namespace:net
posix_connected_socket_impl	posix-stack.cc	/^    explicit posix_connected_socket_impl(lw_shared_ptr<pollable_fd> fd) : _fd(std::move(fd)) {}$/;"	f	class:net::final	file:
posix_connected_socket_operations	posix-stack.cc	/^class posix_connected_socket_operations<transport::SCTP> {$/;"	c	namespace:net	file:
posix_connected_socket_operations	posix-stack.cc	/^class posix_connected_socket_operations<transport::TCP> {$/;"	c	namespace:net	file:
posix_data_sink	posix-stack.cc	/^data_sink posix_data_sink(pollable_fd& fd) {$/;"	f	namespace:net
posix_data_sink_impl	posix-stack.hh	/^    explicit posix_data_sink_impl(pollable_fd& fd) : _fd(fd) {}$/;"	f	class:net::posix_data_sink_impl
posix_data_sink_impl	posix-stack.hh	/^class posix_data_sink_impl : public data_sink_impl {$/;"	c	namespace:net
posix_data_source	posix-stack.cc	/^data_source posix_data_source(pollable_fd& fd) {$/;"	f	namespace:net
posix_data_source_impl	posix-stack.hh	/^    explicit posix_data_source_impl(pollable_fd& fd, size_t buf_size = 8192)$/;"	f	class:net::final
posix_datagram	posix-stack.cc	/^    posix_datagram(ipv4_addr src, ipv4_addr dst, packet p) : _src(src), _dst(dst), _p(std::move(p)) {}$/;"	f	class:net::posix_datagram
posix_datagram	posix-stack.cc	/^class posix_datagram : public udp_datagram_impl {$/;"	c	namespace:net	file:
posix_network_stack	posix-stack.hh	/^    explicit posix_network_stack(boost::program_options::variables_map opts) : _reuseport(engine().posix_reuseport_available()) {}$/;"	f	class:net::posix_network_stack
posix_network_stack	posix-stack.hh	/^class posix_network_stack : public network_stack {$/;"	c	namespace:net
posix_reuseport_server_socket_impl	posix-stack.hh	/^    explicit posix_reuseport_server_socket_impl(socket_address sa, pollable_fd lfd) : _sa(sa), _lfd(std::move(lfd)) {}$/;"	f	class:net::posix_reuseport_server_socket_impl
posix_reuseport_server_socket_impl	posix-stack.hh	/^class posix_reuseport_server_socket_impl : public server_socket_impl {$/;"	c	namespace:net
posix_server_socket_impl	posix-stack.hh	/^    explicit posix_server_socket_impl(socket_address sa, pollable_fd lfd) : _sa(sa), _lfd(std::move(lfd)) {}$/;"	f	class:net::posix_server_socket_impl
posix_server_socket_impl	posix-stack.hh	/^class posix_server_socket_impl : public server_socket_impl {$/;"	c	namespace:net
posix_udp_channel	posix-stack.cc	/^    posix_udp_channel(ipv4_addr bind_address)$/;"	f	class:net::posix_udp_channel
posix_udp_channel	posix-stack.cc	/^class posix_udp_channel : public udp_channel_impl {$/;"	c	namespace:net	file:
post	virtio.cc	/^qp::txq::post(circular_buffer<packet>& pb) {$/;"	f	class:virtio::qp::txq
post	virtio.cc	/^void vring<BufferChain, Completion>::post(Iterator begin, Iterator end) {$/;"	f	class:virtio::vring
prepare	posix-stack.cc	/^        void prepare() {$/;"	f	struct:net::posix_udp_channel::recv_ctx
prepare	posix-stack.cc	/^        void prepare(ipv4_addr dst, packet p) {$/;"	f	struct:net::posix_udp_channel::send_ctx
prepare_buffers	virtio.cc	/^qp::rxq::prepare_buffers() {$/;"	f	class:virtio::qp::rxq
prepend_header	packet.hh	/^packet::prepend_header(size_t extra_size) {$/;"	f	class:net::packet
prepend_uninitialized_header	packet.hh	/^char* packet::prepend_uninitialized_header(size_t size) {$/;"	f	class:net::packet
private_end	dpdk.cc	/^        MARKER private_end;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
private_start	dpdk.cc	/^        MARKER private_start;$/;"	m	class:dpdk::dpdk_qp::tx_buf	file:
process_packet	arp.cc	/^arp::process_packet(packet p, ethernet_address from) {$/;"	f	class:net::arp
process_packet	dhcp.cc	/^    future<> process_packet(packet p, dhcp_payload* dhp, size_t opt_off) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
process_packets	dpdk.cc	/^void dpdk_qp<HugetlbfsMemBackend>::process_packets($/;"	f	class:dpdk::dpdk_qp
process_ring	xenfront.cc	/^void front_ring<T>::process_ring(std::function<bool (gntref &entry, T& el)> func, grant_head *refs)$/;"	f	class:xen::front_ring
proto	api.hh	/^    seastar::transport proto = seastar::transport::TCP;$/;"	m	struct:seastar::listen_options
proto_num	ip.hh	/^        ip_protocol_num proto_num;$/;"	m	struct:net::ipv4_traits::l4packet
proto_num	net.hh	/^        eth_protocol_num proto_num;$/;"	m	struct:net::l3_protocol::l3packet
protocol	ip.hh	/^    uint8_t protocol;$/;"	m	struct:net::ipv4_frag_id
protocol	packet.hh	/^    ip_protocol_num protocol = ip_protocol_num::unused;$/;"	m	struct:net::offload_info
proxy_net_device	proxy.cc	/^class proxy_net_device : public qp {$/;"	c	namespace:net	file:
proxy_net_device	proxy.cc	/^proxy_net_device::proxy_net_device(unsigned cpu, device* dev) :$/;"	f	class:net::proxy_net_device
proxy_send	net.hh	/^    void proxy_send(packet p) {$/;"	f	class:net::qp
pseudo_vector	packet.hh	/^        pseudo_vector(fragment* start, size_t nr)$/;"	f	struct:net::final::pseudo_vector
pseudo_vector	packet.hh	/^    struct pseudo_vector {$/;"	s	class:net::final
ptype	arp.hh	/^        packed<uint16_t> ptype;$/;"	m	struct:net::arp::arp_hdr
ptype	arp.hh	/^        packed<uint16_t> ptype;$/;"	m	struct:net::arp_for::arp_hdr
pull	tls.cc	/^    ssize_t pull(void* dst, size_t len) {$/;"	f	class:seastar::tls::session
pull_wrapper	tls.cc	/^    static ssize_t pull_wrapper(gnutls_transport_ptr_t ptr, void* dst, size_t len) {$/;"	f	class:seastar::tls::session
push_back	net.hh	/^    void push_back(uint16_t b) {$/;"	f	class:net::forward_hash
push_back	net.hh	/^    void push_back(uint32_t b) {$/;"	f	class:net::forward_hash
push_back	net.hh	/^    void push_back(uint8_t b) {$/;"	f	class:net::forward_hash
put	dpdk.cc	/^        void put(tx_buf* buf) {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory
put	posix-stack.cc	/^posix_data_sink_impl::put(packet p) {$/;"	f	class:net::posix_data_sink_impl
put	posix-stack.cc	/^posix_data_sink_impl::put(temporary_buffer<char> buf) {$/;"	f	class:net::posix_data_sink_impl
put	tls.cc	/^    future<> put(net::packet p, frag_iter i, frag_iter e, size_t off = 0) {$/;"	f	class:seastar::tls::session::sink_impl	file:
q	virtio.cc	/^            rxq& q;$/;"	m	struct:virtio::qp::rxq::complete	file:
q	virtio.cc	/^            txq& q;$/;"	m	struct:virtio::qp::txq::complete	file:
qp	net.cc	/^qp::qp(bool register_copy_stats,$/;"	f	class:net::qp
qp	net.hh	/^class qp {$/;"	c	namespace:net
qp	virtio.cc	/^class qp : public net::qp {$/;"	c	namespace:virtio	file:
qp	virtio.cc	/^qp::qp(device* dev, size_t rx_ring_size, size_t tx_ring_size)$/;"	f	class:virtio::qp
qp_mempool_obj_size	dpdk.cc	/^uint32_t qp_mempool_obj_size(bool hugetlbfs_membackend)$/;"	f	namespace:dpdk
qp_osv	virtio.cc	/^class qp_osv : public qp {$/;"	c	namespace:virtio	file:
qp_osv	virtio.cc	/^qp_osv::qp_osv(device *dev, osv::assigned_virtio &virtio,$/;"	f	class:virtio::qp_osv
qp_stats	net.hh	/^    qp_stats() : rx{}, tx{} {}$/;"	f	struct:net::qp_stats
qp_stats	net.hh	/^struct qp_stats {$/;"	s	namespace:net
qp_stats_good	net.hh	/^struct qp_stats_good {$/;"	s	namespace:net
qp_vhost	virtio.cc	/^class qp_vhost : public qp {$/;"	c	namespace:virtio	file:
qp_vhost	virtio.cc	/^qp_vhost::qp_vhost(device *dev, boost::program_options::variables_map opts)$/;"	f	class:virtio::qp_vhost
queue_for_cpu	net.hh	/^    qp& queue_for_cpu(unsigned cpu) { return *_queues[cpu]; }$/;"	f	class:net::device
queue_packet	tcp.hh	/^        void queue_packet(packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
queue_rx_packet	xenfront.cc	/^future<> xenfront_qp::queue_rx_packet()$/;"	f	class:xen::xenfront_qp
queued_len	tcp.hh	/^            uint32_t queued_len = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
raw	tcp.hh	/^    uint32_t raw;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_seq
read	tcp.hh	/^        packet read() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
read	tcp.hh	/^packet tcp<InetTraits>::tcb::read() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
read_fully	tls.cc	/^static future<temporary_buffer<char>> read_fully(const sstring& name, const sstring& what) {$/;"	f	file:
ready	net.hh	/^        future<> ready;$/;"	m	struct:net::interface::l3_rx_stream
ready_promise	native-stack.cc	/^    static thread_local promise<std::unique_ptr<network_stack>> ready_promise;$/;"	m	class:net::native_network_stack	file:
ready_promise	native-stack.cc	/^thread_local promise<std::unique_ptr<network_stack>> native_network_stack::ready_promise;$/;"	m	class:net::native_network_stack	file:
reassembled	packet.hh	/^    bool reassembled = false;$/;"	m	struct:net::offload_info
rebind_time	dhcp.hh	/^        std::chrono::seconds rebind_time;$/;"	m	struct:net::dhcp::lease
receive	net.cc	/^device::receive(std::function<future<> (packet)> next_packet) {$/;"	f	class:net::device
receive	net.cc	/^subscription<packet, ethernet_address> l3_protocol::receive($/;"	f	class:net::l3_protocol
receive	posix-stack.cc	/^posix_udp_channel::receive() {$/;"	f	class:net::posix_udp_channel
receive	stack.cc	/^future<net::udp_datagram> net::udp_channel::receive() {$/;"	f	class:net::udp_channel
receive	tcp.hh	/^        struct receive {$/;"	s	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
received	arp.hh	/^arp_for<L3>::received(packet p) {$/;"	f	class:net::arp_for
received	ip.cc	/^void icmp::received(packet p, ipaddr from, ipaddr to) {$/;"	f	class:net::icmp
received	ip.hh	/^    virtual void received(packet p, ipv4_address from, ipv4_address to) {$/;"	f	class:net::final
received	tcp.cc	/^void ipv4_tcp::received(packet p, ipv4_address from, ipv4_address to) {$/;"	f	class:net::ipv4_tcp
received	tcp.hh	/^void tcp<InetTraits>::received(packet p, ipaddr from, ipaddr to) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp
received	udp.cc	/^void ipv4_udp::received(packet p, ipv4_address from, ipv4_address to)$/;"	f	class:net::ipv4_udp
recover	tcp.hh	/^            tcp_seq recover;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
recv_ctx	posix-stack.cc	/^        recv_ctx() {$/;"	f	struct:net::posix_udp_channel::recv_ctx
recv_ctx	posix-stack.cc	/^    struct recv_ctx {$/;"	s	class:net::posix_udp_channel	file:
recycle	dpdk.cc	/^        void recycle() {$/;"	f	class:dpdk::dpdk_qp::tx_buf
ref	xenfront.hh	/^    int32_t  ref = -1;$/;"	m	class:xen::front_ring
refill_one_cluster	dpdk.cc	/^inline bool dpdk_qp<HugetlbfsMemBackend>::refill_one_cluster(rte_mbuf* head)$/;"	f	class:dpdk::dpdk_qp
refill_rx_mbuf	dpdk.cc	/^    static bool refill_rx_mbuf(rte_mbuf* m, size_t size = mbuf_data_size) {$/;"	f	class:dpdk::dpdk_qp	file:
register_l3	net.cc	/^interface::register_l3(eth_protocol_num proto_num,$/;"	f	class:net::interface
register_packet_provider	ip.hh	/^    void register_packet_provider(ipv4_traits::packet_provider_type&& func) {$/;"	f	class:net::ipv4
register_packet_provider	ip.hh	/^void ipv4_l4<ProtoNum>::register_packet_provider(ipv4_traits::packet_provider_type func) {$/;"	f	class:net::ipv4_l4
register_packet_provider	net.hh	/^    void register_packet_provider(l3_protocol::packet_provider_type func) {$/;"	f	class:net::interface
register_packet_provider	net.hh	/^    void register_packet_provider(packet_provider_type func) {$/;"	f	class:net::qp
registration	ip.hh	/^        registration(ipv4_udp &proto, uint16_t port) : _proto(proto), _port(port) {};$/;"	f	class:net::ipv4_udp::registration
registration	ip.hh	/^    class registration {$/;"	c	class:net::ipv4_udp
release	packet.hh	/^    std::vector<temporary_buffer<char>> release() {$/;"	f	class:net::final
release_into	packet.hh	/^    void release_into(Func&& func) {$/;"	f	class:net::final
remove_from_tcbs	tcp.hh	/^        void remove_from_tcbs() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
renew	dhcp.cc	/^net::dhcp::result_type net::dhcp::renew(const lease & l, const steady_clock_type::duration & timeout) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
renew_time	dhcp.hh	/^        std::chrono::seconds renew_time;$/;"	m	struct:net::dhcp::lease
req	dhcp.cc	/^        req_opt_type req;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::requested_option	file:
req	xenfront.hh	/^    struct netif_rx_request  req;$/;"	m	union:xen::rx	typeref:struct:xen::rx::netif_rx_request
req	xenfront.hh	/^    struct netif_tx_request  req;$/;"	m	union:xen::tx	typeref:struct:xen::tx::netif_tx_request
req_event	xenfront.hh	/^    uint32_t req_event = 1;$/;"	m	class:xen::sring
req_opt_type	dhcp.cc	/^    typedef std::array<opt_type, 5> req_opt_type;$/;"	t	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
req_prod	xenfront.hh	/^    uint32_t req_prod = 0;$/;"	m	class:xen::sring
req_prod_pvt	xenfront.hh	/^    uint32_t req_prod_pvt = 0;$/;"	m	class:xen::front_ring
requested_option	dhcp.cc	/^        requested_option()$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::requested_option
requested_option	dhcp.cc	/^    struct requested_option: public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
requested_options	dhcp.cc	/^    static const req_opt_type requested_options;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
requested_options	dhcp.cc	/^const net::dhcp::impl::req_opt_type net::dhcp::impl::requested_options = { {$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp::impl	file:
reserve	packet.hh	/^    void reserve(int n_frags) {$/;"	f	class:net::final
reserved	ip.hh	/^    enum class frag_bits : uint8_t { mf = 13, df = 14, reserved = 15, offset_shift = 3 };$/;"	m	class:net::ip_hdr::frag_bits
reset	packet.hh	/^    void reset() { _impl.reset(); }$/;"	f	class:net::final
reset_zc	dpdk.cc	/^        void reset_zc() {$/;"	f	class:dpdk::dpdk_qp::tx_buf
resolution	arp.hh	/^    struct resolution {$/;"	s	class:net::arp_for
respond_with_reset	tcp.hh	/^void tcp<InetTraits>::respond_with_reset(tcp_hdr* rth, ipaddr local_ip, ipaddr foreign_ip) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp
respond_with_reset	tcp.hh	/^void tcp<InetTraits>::tcb::respond_with_reset(tcp_hdr* rth) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
rest	ip.hh	/^    packed<uint32_t> rest;$/;"	m	struct:net::icmp_hdr
result_type	dhcp.hh	/^    typedef future<bool, lease> result_type;$/;"	t	class:net::dhcp
retransmit	tcp.hh	/^void tcp<InetTraits>::tcb::retransmit() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
retransmit_one	tcp.hh	/^        void retransmit_one() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
reuse_address	api.hh	/^    bool reuse_address = false;$/;"	m	struct:seastar::listen_options
ring_config	virtio.cc	/^struct ring_config {$/;"	s	namespace:virtio	file:
rmb	xenfront.cc	/^#define rmb(/;"	d	file:
rsp	xenfront.hh	/^    struct netif_rx_response rsp;$/;"	m	union:xen::rx	typeref:struct:xen::rx::netif_rx_response
rsp	xenfront.hh	/^    struct netif_tx_response rsp;$/;"	m	union:xen::tx	typeref:struct:xen::tx::netif_tx_response
rsp_cons	xenfront.hh	/^    uint32_t rsp_cons = 0;$/;"	m	class:xen::front_ring
rsp_event	xenfront.hh	/^    uint32_t rsp_event = 1;$/;"	m	class:xen::sring
rsp_prod	xenfront.hh	/^    uint32_t rsp_prod = 0;$/;"	m	class:xen::sring
rss_hash	packet.hh	/^    std::experimental::optional<uint32_t> rss_hash() {$/;"	f	class:net::final
rss_key	net.cc	/^const rss_key_type& interface::rss_key() const {$/;"	f	class:net::interface
rss_key	net.hh	/^    virtual const rss_key_type& rss_key() const { return default_rsskey_40bytes; }$/;"	f	class:net::device
rsvd1	tcp.hh	/^    uint8_t rsvd1 : 4;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
rsvd2	tcp.hh	/^    uint8_t rsvd2 : 2;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
rte_mbuf_p	dpdk.cc	/^        rte_mbuf* rte_mbuf_p() { return &_mbuf; }$/;"	f	class:dpdk::dpdk_qp::tx_buf
rte_mbuf_to_baddr	dpdk.cc	/^rte_mbuf_to_baddr(rte_mbuf* mbuf) {$/;"	f	file:
rttvar	tcp.hh	/^            std::chrono::milliseconds rttvar;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
run	dhcp.cc	/^    future<bool, lease> run(const lease & l,$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
run	virtio.cc	/^        void run() {$/;"	f	class:virtio::qp::rxq
run_dhcp	native-stack.cc	/^future<> native_network_stack::run_dhcp(bool is_renew, const dhcp::lease& res) {$/;"	f	class:net::native_network_stack
rx	dpdk.cc	/^    } rx;$/;"	m	struct:dpdk::port_stats	typeref:struct:dpdk::port_stats::__anon3	file:
rx	net.hh	/^    } rx;$/;"	m	struct:net::qp_stats	typeref:struct:net::qp_stats::__anon9
rx	xenfront.hh	/^union rx {$/;"	u	namespace:xen
rx_csum_offload	net.hh	/^    bool rx_csum_offload = false;$/;"	m	struct:net::hw_features
rx_gc	dpdk.cc	/^bool dpdk_qp<HugetlbfsMemBackend>::rx_gc()$/;"	f	class:dpdk::dpdk_qp
rx_gc_thresh	dpdk.cc	/^static constexpr uint16_t rx_gc_thresh           = 64;$/;"	m	namespace:dpdk	file:
rx_lro	net.hh	/^    bool rx_lro = false;$/;"	m	struct:net::hw_features
rx_start	dpdk.cc	/^void dpdk_qp<HugetlbfsMemBackend>::rx_start() {$/;"	f	class:dpdk::dpdk_qp
rx_start	net.hh	/^    virtual void rx_start() {};$/;"	f	class:net::qp
rx_start	virtio.cc	/^qp::rx_start() {$/;"	f	class:virtio::qp
rx_start	xenfront.cc	/^xenfront_qp::rx_start() {$/;"	f	class:xen::xenfront_qp
rx_time	ip.hh	/^        clock_type::time_point rx_time;$/;"	m	struct:net::ipv4::frag
rxq	virtio.cc	/^    class rxq  {$/;"	c	class:virtio::qp	file:
rxq	virtio.cc	/^qp::rxq::rxq(qp& dev, ring_config config)$/;"	f	class:virtio::qp::rxq
rxq_config	virtio.cc	/^ring_config qp::rxq_config(size_t rx_ring_size) {$/;"	f	class:virtio::qp
sa	api.hh	/^        ::sockaddr sa;$/;"	m	union:socket_address::__anon2
sack	tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
sack	tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
sack	tcp.hh	/^    struct sack {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
sas	api.hh	/^        ::sockaddr_storage sas;$/;"	m	union:socket_address::__anon2
sctp_keepalive_params	api.hh	/^struct sctp_keepalive_params {$/;"	s	namespace:seastar::net
seastar	api.hh	/^namespace seastar {$/;"	n
seastar	api.hh	/^namespace seastar {$/;"	n	namespace:seastar
seastar	tls.cc	/^namespace seastar {$/;"	n	file:
seastar	tls.hh	/^namespace seastar {$/;"	n
secs	dhcp.cc	/^        packed<uint16_t> secs = 0;          \/\/ Client sets seconds elapsed since op start$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
segment_acceptable	tcp.hh	/^bool tcp<InetTraits>::tcb::segment_acceptable(tcp_seq seg_seq, unsigned seg_len) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
send	arp.hh	/^void arp_for<L3>::send(l2addr to, packet p) {$/;"	f	class:net::arp_for
send	dhcp.cc	/^    future<> send(T && pkt) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
send	ip.cc	/^void ipv4::send(ipv4_address to, ip_protocol_num proto_num, packet p, ethernet_address e_dst) {$/;"	f	class:net::ipv4
send	net.hh	/^    virtual uint32_t send(circular_buffer<packet>& p) {$/;"	f	class:net::qp
send	posix-stack.cc	/^future<> posix_udp_channel::send(ipv4_addr dst, const char *message) {$/;"	f	class:net::posix_udp_channel
send	posix-stack.cc	/^future<> posix_udp_channel::send(ipv4_addr dst, packet p) {$/;"	f	class:net::posix_udp_channel
send	proxy.cc	/^uint32_t proxy_net_device::send(circular_buffer<packet>& p)$/;"	f	class:net::proxy_net_device
send	stack.cc	/^future<> net::udp_channel::send(ipv4_addr dst, const char* msg) {$/;"	f	class:net::udp_channel
send	stack.cc	/^future<> net::udp_channel::send(ipv4_addr dst, packet p) {$/;"	f	class:net::udp_channel
send	tcp.hh	/^        future<> send(packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
send	tcp.hh	/^        struct send {$/;"	s	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
send	tcp.hh	/^future<> tcp<InetTraits>::tcb::send(packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
send	udp.cc	/^void ipv4_udp::send(uint16_t src_port, ipv4_addr dst, packet &&p)$/;"	f	class:net::ipv4_udp
send	virtio.cc	/^qp::send(circular_buffer<packet>& p) {$/;"	f	class:virtio::qp
send	xenfront.cc	/^xenfront_qp::send(packet _p) {$/;"	f	class:xen::xenfront_qp
send_ctx	posix-stack.cc	/^        send_ctx() {$/;"	f	struct:net::posix_udp_channel::send_ctx
send_ctx	posix-stack.cc	/^    struct send_ctx {$/;"	s	class:net::posix_udp_channel	file:
send_discover	dhcp.cc	/^    future<> send_discover(const ipv4_address & ip = ipv4_address()) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
send_packet_without_tcb	tcp.hh	/^void tcp<InetTraits>::send_packet_without_tcb(ipaddr from, ipaddr to, packet p) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp
send_query	arp.hh	/^arp_for<L3>::send_query(const l3addr& paddr) {$/;"	f	class:net::arp_for
send_request	dhcp.cc	/^    future<> send_request(const lease & info) {$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
sender_hwaddr	arp.hh	/^        l2addr sender_hwaddr;$/;"	m	struct:net::arp_for::arp_hdr
sender_paddr	arp.hh	/^        l3addr sender_paddr;$/;"	m	struct:net::arp_for::arp_hdr
seq	tcp.hh	/^    packed<tcp_seq> seq;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
server_credentials	tls.cc	/^seastar::tls::server_credentials::server_credentials(::shared_ptr<dh_params> dh)$/;"	f	class:seastar::tls::server_credentials
server_credentials	tls.cc	/^seastar::tls::server_credentials::server_credentials(const dh_params& dh) {$/;"	f	class:seastar::tls::server_credentials
server_credentials	tls.hh	/^    class server_credentials : public certificate_credentials {$/;"	c	class:seastar::tls::dh_params
server_port	dhcp.cc	/^    static const uint16_t server_port = 67;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
server_port	dhcp.cc	/^const uint16_t net::dhcp::impl::server_port;$/;"	m	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp::impl	file:
server_session	tls.cc	/^    server_session(::shared_ptr<server_credentials> creds, ::server_socket sock)$/;"	f	class:seastar::tls::server_session
server_session	tls.cc	/^class server_session : public net::server_socket_impl {$/;"	c	namespace:seastar::tls	file:
server_socket	api.hh	/^class server_socket {$/;"	c	namespace:seastar
server_socket	stack.cc	/^server_socket::server_socket() {$/;"	f	class:server_socket
server_socket	stack.cc	/^server_socket::server_socket(std::unique_ptr<net::server_socket_impl> ssi)$/;"	f	class:server_socket
server_socket_impl	stack.hh	/^class server_socket_impl {$/;"	c	namespace:net
session	tls.cc	/^    session(type t, ::shared_ptr<certificate_credentials> creds,$/;"	f	class:seastar::tls::session
session	tls.cc	/^class session: public net::connected_socket_impl {$/;"	c	namespace:seastar::tls	file:
set	dhcp.cc	/^        void set(opt_type type, const ipv4_address & ip) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_info
set	dhcp.cc	/^        void set(opt_type type, std::chrono::seconds s) {$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_info
set_cluster_offload_info	dpdk.cc	/^        static void set_cluster_offload_info(const packet& p, const dpdk_qp& qp, rte_mbuf* head) {$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
set_dh_level	tls.cc	/^void seastar::tls::credentials_builder::set_dh_level(dh_params::level level) {$/;"	f	class:seastar::tls::credentials_builder
set_gw_address	ip.cc	/^void ipv4::set_gw_address(ipv4_address ip) {$/;"	f	class:net::ipv4
set_host_address	ip.cc	/^void ipv4::set_host_address(ipv4_address ip) {$/;"	f	class:net::ipv4
set_hw_flow_control	dpdk.cc	/^void dpdk_device::set_hw_flow_control()$/;"	f	class:dpdk::dpdk_device
set_ipv4_packet_filter	native-stack.cc	/^    void set_ipv4_packet_filter(ip_packet_filter* filter) {$/;"	f	class:net::native_network_stack	file:
set_keepalive	native-stack-impl.hh	/^void native_connected_socket_impl<Protocol>::set_keepalive(bool keepalive) {$/;"	f	class:net::native_connected_socket_impl
set_keepalive	posix-stack.cc	/^    void set_keepalive(file_desc& _fd, bool keepalive) {$/;"	f	class:net::posix_connected_socket_operations
set_keepalive	stack.cc	/^void connected_socket::set_keepalive(bool keepalive) {$/;"	f	class:connected_socket
set_keepalive_parameters	native-stack-impl.hh	/^void native_connected_socket_impl<Protocol>::set_keepalive_parameters(const keepalive_params&) {$/;"	f	class:net::native_connected_socket_impl
set_keepalive_parameters	posix-stack.cc	/^    void set_keepalive_parameters(file_desc& _fd, const keepalive_params& kpms) {$/;"	f	class:net::posix_connected_socket_operations
set_keepalive_parameters	posix-stack.cc	/^    void set_keepalive_parameters(file_desc& _fd, const keepalive_params& params) {$/;"	f	class:net::posix_connected_socket_operations
set_keepalive_parameters	stack.cc	/^void connected_socket::set_keepalive_parameters(const net::keepalive_params& p) {$/;"	f	class:connected_socket
set_local_queue	net.cc	/^void device::set_local_queue(std::unique_ptr<qp> dev) {$/;"	f	class:net::device
set_netmask_address	ip.cc	/^void ipv4::set_netmask_address(ipv4_address ip) {$/;"	f	class:net::ipv4
set_nodelay	native-stack-impl.hh	/^native_connected_socket_impl<Protocol>::set_nodelay(bool nodelay) {$/;"	f	class:net::native_connected_socket_impl
set_nodelay	posix-stack.cc	/^    void set_nodelay(file_desc& _fd, bool nodelay) {$/;"	f	class:net::posix_connected_socket_operations
set_nodelay	stack.cc	/^void connected_socket::set_nodelay(bool nodelay) {$/;"	f	class:connected_socket
set_notifier	virtio.cc	/^        void set_notifier(std::unique_ptr<notifier> notifier) {$/;"	f	class:virtio::qp::rxq
set_notifier	virtio.cc	/^        void set_notifier(std::unique_ptr<notifier> notifier) {$/;"	f	class:virtio::qp::txq
set_notifier	virtio.cc	/^    void set_notifier(std::unique_ptr<notifier> notifier) {$/;"	f	class:virtio::vring
set_offload_info	packet.hh	/^    void set_offload_info(class offload_info oi) { _impl->_offload_info = oi; }$/;"	f	class:net::final
set_one_data_buf	dpdk.cc	/^        static size_t set_one_data_buf($/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
set_packet	dpdk.cc	/^        void set_packet(packet&& p) {$/;"	f	class:dpdk::dpdk_qp::tx_buf
set_packet_filter	ip.cc	/^void ipv4::set_packet_filter(ip_packet_filter * f) {$/;"	f	class:net::ipv4
set_queue_size	ip.hh	/^    void set_queue_size(int size) { _queue_size = size; }$/;"	f	class:net::ipv4_udp
set_rss_hash	packet.hh	/^    std::experimental::optional<uint32_t> set_rss_hash(uint32_t hash) {$/;"	f	class:net::final
set_rss_table	dpdk.cc	/^void dpdk_device::set_rss_table()$/;"	f	class:dpdk::dpdk_device
set_self_addr	arp.hh	/^    void set_self_addr(l3addr addr) {$/;"	f	class:net::arp_for
set_simple_pkcs12	tls.cc	/^    void set_simple_pkcs12(const blob& b, x509_crt_format fmt,$/;"	f	class:seastar::tls::certificate_credentials::impl
set_simple_pkcs12	tls.cc	/^void seastar::tls::certificate_credentials::set_simple_pkcs12(const blob& b,$/;"	f	class:seastar::tls::certificate_credentials
set_simple_pkcs12	tls.cc	/^void seastar::tls::credentials_builder::set_simple_pkcs12(const blob& b, x509_crt_format fmt, const sstring& password) {$/;"	f	class:seastar::tls::credentials_builder
set_simple_pkcs12_file	tls.cc	/^future<> seastar::tls::abstract_credentials::set_simple_pkcs12_file($/;"	f	class:seastar::tls::abstract_credentials
set_system_trust	tls.cc	/^    future<> set_system_trust() {$/;"	f	class:seastar::tls::certificate_credentials::impl
set_system_trust	tls.cc	/^future<> seastar::tls::certificate_credentials::set_system_trust() {$/;"	f	class:seastar::tls::certificate_credentials
set_system_trust	tls.cc	/^future<> seastar::tls::credentials_builder::set_system_trust() {$/;"	f	class:seastar::tls::credentials_builder
set_x509_crl	tls.cc	/^    void set_x509_crl(const blob& b, x509_crt_format fmt) {$/;"	f	class:seastar::tls::certificate_credentials::impl
set_x509_crl	tls.cc	/^void seastar::tls::certificate_credentials::set_x509_crl(const blob& b,$/;"	f	class:seastar::tls::certificate_credentials
set_x509_crl	tls.cc	/^void seastar::tls::credentials_builder::set_x509_crl(const blob& b, x509_crt_format fmt) {$/;"	f	class:seastar::tls::credentials_builder
set_x509_crl_file	tls.cc	/^future<> seastar::tls::abstract_credentials::set_x509_crl_file($/;"	f	class:seastar::tls::abstract_credentials
set_x509_key	tls.cc	/^    void set_x509_key(const blob& cert, const blob& key, x509_crt_format fmt) {$/;"	f	class:seastar::tls::certificate_credentials::impl
set_x509_key	tls.cc	/^void seastar::tls::certificate_credentials::set_x509_key(const blob& cert,$/;"	f	class:seastar::tls::certificate_credentials
set_x509_key	tls.cc	/^void seastar::tls::credentials_builder::set_x509_key(const blob& cert, const blob& key, x509_crt_format fmt) {$/;"	f	class:seastar::tls::credentials_builder
set_x509_key_file	tls.cc	/^future<> seastar::tls::abstract_credentials::set_x509_key_file($/;"	f	class:seastar::tls::abstract_credentials
set_x509_trust	tls.cc	/^    void set_x509_trust(const blob& b, x509_crt_format fmt) {$/;"	f	class:seastar::tls::certificate_credentials::impl
set_x509_trust	tls.cc	/^void seastar::tls::certificate_credentials::set_x509_trust(const blob& b,$/;"	f	class:seastar::tls::certificate_credentials
set_x509_trust	tls.cc	/^void seastar::tls::credentials_builder::set_x509_trust(const blob& b, x509_crt_format fmt) {$/;"	f	class:seastar::tls::credentials_builder
set_x509_trust_file	tls.cc	/^future<> seastar::tls::abstract_credentials::set_x509_trust_file($/;"	f	class:seastar::tls::abstract_credentials
set_zc_info	dpdk.cc	/^        void set_zc_info(void* va, phys_addr_t pa, size_t len) {$/;"	f	class:dpdk::dpdk_qp::tx_buf
setup	virtio.cc	/^void vring<BufferChain, Completion>::setup() {$/;"	f	class:virtio::vring
setup_features	virtio.cc	/^    uint64_t setup_features() {$/;"	f	class:virtio::device	file:
share	packet.hh	/^packet packet::share() {$/;"	f	class:net::packet
share	packet.hh	/^packet packet::share(size_t offset, size_t len) {$/;"	f	class:net::packet
shift	tcp.hh	/^        uint8_t shift;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::win_scale
should_send_ack	tcp.hh	/^bool tcp<InetTraits>::tcb::should_send_ack(uint16_t seg_len) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
shutdown	stack.cc	/^void seastar::socket::shutdown() {$/;"	f	class:seastar::socket
shutdown	tls.cc	/^    future<> shutdown(gnutls_close_request_t how) {$/;"	f	class:seastar::tls::session
shutdown_connect	tcp.hh	/^void tcp<InetTraits>::connection::shutdown_connect() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
shutdown_input	native-stack-impl.hh	/^native_connected_socket_impl<Protocol>::shutdown_input() {$/;"	f	class:net::native_connected_socket_impl
shutdown_input	stack.cc	/^future<> connected_socket::shutdown_input() {$/;"	f	class:connected_socket
shutdown_output	native-stack-impl.hh	/^native_connected_socket_impl<Protocol>::shutdown_output() {$/;"	f	class:net::native_connected_socket_impl
shutdown_output	stack.cc	/^future<> connected_socket::shutdown_output() {$/;"	f	class:connected_socket
siaddr	dhcp.cc	/^        ipv4_address siaddr;  \/\/ IP address of next server to use in bootstrap$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
signal_all_data_acked	tcp.hh	/^        void signal_all_data_acked() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
signal_data_received	tcp.hh	/^        void signal_data_received() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
sink	native-stack-impl.hh	/^data_sink native_connected_socket_impl<Protocol>::sink() {$/;"	f	class:net::native_connected_socket_impl
sink	tls.cc	/^data_sink seastar::tls::session::sink() {$/;"	f	class:seastar::tls::session
sink_impl	tls.cc	/^    sink_impl(session& s)$/;"	f	class:seastar::tls::session::sink_impl
sink_impl	tls.cc	/^class session::sink_impl: public ::data_sink_impl {$/;"	c	class:seastar::tls::session	file:
size	net.hh	/^    size_t size() const {$/;"	f	class:net::forward_hash
size	packet.hh	/^    size_t size;$/;"	m	struct:net::fragment
size	virtio.cc	/^    int size() { return _config.size; }$/;"	f	class:virtio::vring
size	virtio.cc	/^    unsigned size;$/;"	m	struct:virtio::ring_config	file:
size	xenfront.hh	/^    uint16_t size;$/;"	m	struct:xen::netif_tx_request
sname	dhcp.cc	/^        char sname[64] = { 0, };         \/\/ unused$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
socket	api.hh	/^class socket {$/;"	c	namespace:seastar::seastar
socket	native-stack.cc	/^seastar::socket native_network_stack::socket() {$/;"	f	class:net::native_network_stack
socket	posix-stack.cc	/^::seastar::socket posix_network_stack::socket() {$/;"	f	class:net::posix_network_stack
socket	stack.cc	/^seastar::socket::socket($/;"	f	class:seastar::socket
socket	tls.cc	/^seastar::socket seastar::tls::socket(::shared_ptr<certificate_credentials> cred, sstring name) {$/;"	f	class:seastar::tls
socket_address	api.hh	/^    socket_address(sockaddr_in sa) {$/;"	f	class:socket_address
socket_address	api.hh	/^class socket_address {$/;"	c
socket_address	stack.cc	/^socket_address::socket_address(ipv4_addr addr)$/;"	f	class:socket_address
socket_impl	stack.hh	/^class socket_impl {$/;"	c	namespace:net
sockets	posix-stack.cc	/^thread_local std::unordered_map<::sockaddr_in, promise<connected_socket, socket_address>> posix_ap_server_socket_impl<Transport>::sockets;$/;"	m	class:net::posix_ap_server_socket_impl	file:
sockets	posix-stack.hh	/^    static thread_local std::unordered_map<::sockaddr_in, promise<connected_socket, socket_address>> sockets;$/;"	m	class:net::posix_ap_server_socket_impl
source	native-stack-impl.hh	/^data_source native_connected_socket_impl<Protocol>::source() {$/;"	f	class:net::native_connected_socket_impl
source	tls.cc	/^data_source seastar::tls::session::source() {$/;"	f	class:seastar::tls::session
source_impl	tls.cc	/^    source_impl(session& s)$/;"	f	class:seastar::tls::session::source_impl
source_impl	tls.cc	/^class session::source_impl: public ::data_source_impl {$/;"	c	class:seastar::tls::session	file:
src_ip	ip.hh	/^    ipv4_address src_ip;$/;"	m	class:net::ip_hdr::frag_bits
src_ip	ip.hh	/^    ipv4_address src_ip;$/;"	m	struct:net::ipv4_frag_id
src_mac	ethernet.hh	/^    ethernet_address src_mac;$/;"	m	struct:net::eth_hdr
src_port	tcp.hh	/^    packed<uint16_t> src_port;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
src_port	udp.hh	/^    packed<uint16_t> src_port;$/;"	m	struct:net::udp_hdr
sring	xenfront.hh	/^class sring {$/;"	c	namespace:xen
srtt	tcp.hh	/^            std::chrono::milliseconds srtt;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
ssthresh	tcp.hh	/^            uint32_t ssthresh;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
start_persist_timer	tcp.hh	/^        void start_persist_timer() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
start_persist_timer	tcp.hh	/^        void start_persist_timer(clock_type::time_point now) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
start_retransmit_timer	tcp.hh	/^        void start_retransmit_timer() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
start_retransmit_timer	tcp.hh	/^        void start_retransmit_timer(clock_type::time_point now) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
state	dhcp.cc	/^    enum class state {$/;"	c	class:net::dhcp::impl	file:
state	tcp.hh	/^        tcp_state& state() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
status	xenfront.hh	/^    int16_t  status;       \/* -ve: NETIF_RSP_* ; +ve: Rx'ed response size. *\/$/;"	m	struct:xen::netif_rx_response
status	xenfront.hh	/^    int16_t  status;$/;"	m	struct:xen::netif_tx_response
std	ip.hh	/^namespace std {$/;"	n
stop_persist_timer	tcp.hh	/^        void stop_persist_timer() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
stop_retransmit_timer	tcp.hh	/^        void stop_retransmit_timer() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
sum	ip_checksum.cc	/^void checksummer::sum(const char* data, size_t len) {$/;"	f	class:net::checksummer
sum	ip_checksum.cc	/^void checksummer::sum(const packet& p) {$/;"	f	class:net::checksummer
sum	ip_checksum.hh	/^    void sum(uint16_t data) {$/;"	f	struct:net::checksummer
sum	ip_checksum.hh	/^    void sum(uint32_t data) {$/;"	f	struct:net::checksummer
sum	ip_checksum.hh	/^    void sum(uint8_t data) {$/;"	f	struct:net::checksummer
sum_many	ip_checksum.hh	/^    void sum_many() {}$/;"	f	struct:net::checksummer
sum_many	ip_checksum.hh	/^    void sum_many(T0 data, T... rest) {$/;"	f	struct:net::checksummer
syn_needs_on	tcp.hh	/^        bool syn_needs_on() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
syn_retransmit	tcp.hh	/^            unsigned syn_retransmit = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
syn_tx_time	tcp.hh	/^            clock_type::time_point syn_tx_time;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
system_trust	tls.cc	/^static const sstring system_trust = "system_trust";$/;"	v	file:
t1	tcp.hh	/^        packed<uint32_t> t1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
t2	tcp.hh	/^        packed<uint32_t> t2;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::option_len::timestamps
target_hwaddr	arp.hh	/^        l2addr target_hwaddr;$/;"	m	struct:net::arp_for::arp_hdr
target_paddr	arp.hh	/^        l3addr target_paddr;$/;"	m	struct:net::arp_for::arp_hdr
tcb	tcp.hh	/^    class tcb : public enable_lw_shared_from_this<tcb> {$/;"	c	class:net::tcp_state::tcp_option::option_kind::tcp
tcb	tcp.hh	/^tcp<InetTraits>::tcb::tcb(tcp& t, connid id)$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
tcp	const.hh	/^    icmp = 1, tcp = 6, udp = 17, unused = 255$/;"	m	class:net::ip_protocol_num
tcp	tcp.hh	/^class tcp {$/;"	c	class:net::tcp_state::tcp_option::option_kind
tcp	tcp.hh	/^tcp<InetTraits>::tcp(inet_type& inet)$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp
tcp_connect_error	tcp.hh	/^inline auto tcp_connect_error() {$/;"	f	namespace:net
tcp_debug	tcp.hh	/^void tcp_debug(const char* fmt, Args&&... args) {$/;"	f	class:net::tcp_state
tcp_error	tcp.hh	/^inline auto tcp_error(int err) {$/;"	f	namespace:net
tcp_hdr	tcp.hh	/^struct tcp_hdr {$/;"	s	class:net::tcp_state::tcp_option::option_kind
tcp_hdr_len	packet.hh	/^    uint8_t tcp_hdr_len = 20;$/;"	m	struct:net::offload_info
tcp_hdr_len_min	const.hh	/^const uint8_t tcp_hdr_len_min = 20;$/;"	m	class:net::ip_protocol_num::eth_protocol_num
tcp_keepalive_params	api.hh	/^struct tcp_keepalive_params {$/;"	s	namespace:seastar::net
tcp_option	tcp.hh	/^struct tcp_option {$/;"	s	class:net::tcp_state
tcp_pseudo_header_checksum	ip.hh	/^    static void tcp_pseudo_header_checksum(checksummer& csum, ipv4_address src, ipv4_address dst, uint16_t len) {$/;"	f	struct:net::ipv4_traits
tcp_refused_error	tcp.hh	/^inline auto tcp_refused_error() {$/;"	f	namespace:net
tcp_reset_error	tcp.hh	/^inline auto tcp_reset_error() {$/;"	f	namespace:net
tcp_seq	tcp.hh	/^struct tcp_seq {$/;"	s	class:net::tcp_state::tcp_option::option_kind
tcp_state	tcp.hh	/^enum class tcp_state : uint16_t {$/;"	c	namespace:net
tcp_tag	tcp.hh	/^struct tcp_tag {};$/;"	s	class:net::tcp_state::tcp_option::option_kind
tcpv4_listen	tcp.cc	/^tcpv4_listen(tcp<ipv4_traits>& tcpv4, uint16_t port, listen_options opts) {$/;"	f	namespace:net
tcpv4_socket	tcp.cc	/^tcpv4_socket(tcp<ipv4_traits>& tcpv4) {$/;"	f	namespace:net
time	dhcp.cc	/^        packed<uint32_t> time;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::time_option	file:
time_option	dhcp.cc	/^        time_option(opt_type t, uint32_t v) : option(t, sizeof(uint32_t)), time(htonl(v)) {}$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::time_option
time_option	dhcp.cc	/^    struct time_option : public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
timestamps	tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
timestamps	tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
timestamps	tcp.hh	/^    struct timestamps {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
tls	tls.cc	/^namespace tls {$/;"	n	namespace:seastar	file:
tls	tls.hh	/^namespace tls {$/;"	n	namespace:seastar
tls_socket_impl	tls.cc	/^    tls_socket_impl(::shared_ptr<certificate_credentials> cred, sstring name)$/;"	f	class:seastar::tls::tls_socket_impl
tls_socket_impl	tls.cc	/^class tls_socket_impl : public net::socket_impl {$/;"	c	namespace:seastar::tls	file:
to	ip.hh	/^        ipv4_address to;$/;"	m	struct:net::ipv4_traits::l4packet
to	net.hh	/^        ethernet_address to;$/;"	m	struct:net::l3_protocol::l3packet
to_gnutls_level	tls.cc	/^    static gnutls_sec_param_t to_gnutls_level(level l) {$/;"	f	class:seastar::tls::dh_params::impl	file:
to_iovec	posix-stack.cc	/^std::vector<iovec> to_iovec(std::vector<temporary_buffer<char>>& buf_vec) {$/;"	f	namespace:net
to_iovec	posix-stack.cc	/^std::vector<struct iovec> to_iovec(const packet& p) {$/;"	f	namespace:net
to_ipv4_addr	udp.cc	/^to_ipv4_addr(ipv4_address a, uint16_t port) {$/;"	f	namespace:net::ipv4_udp_impl
toeplitz_hash	toeplitz.hh	/^toeplitz_hash(const rss_key_type& key, const T& data)$/;"	f
total	dpdk.cc	/^            uint64_t total;        \/\/ total number of erroneous received packets$/;"	m	struct:dpdk::port_stats::__anon3::__anon5	file:
total	dpdk.cc	/^            uint64_t total;   \/\/ total number of failed transmitted packets$/;"	m	struct:dpdk::port_stats::__anon6::__anon8	file:
total	net.hh	/^            uint64_t total;        \/\/ total number of erroneous packets$/;"	m	struct:net::qp_stats::__anon9::__anon10
translate_one_frag	dpdk.cc	/^        static bool translate_one_frag(dpdk_qp& qp, fragment& frag,$/;"	f	class:dpdk::dpdk_qp::tx_buf	file:
transport	api.hh	/^enum class transport {$/;"	c	namespace:seastar
trim_back	packet.hh	/^void packet::trim_back(size_t how_much) {$/;"	f	class:net::packet
trim_front	packet.hh	/^void packet::trim_front(size_t how_much) {$/;"	f	class:net::packet
trim_receive_data_after_window	tcp.hh	/^void tcp<InetTraits>::tcb::trim_receive_data_after_window() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
tso_seg_size	packet.hh	/^    uint16_t tso_seg_size = 0;$/;"	m	struct:net::offload_info
ttl	ip.hh	/^    uint8_t ttl;$/;"	m	class:net::ip_hdr::frag_bits
tx	dpdk.cc	/^    } tx;$/;"	m	struct:dpdk::port_stats	typeref:struct:dpdk::port_stats::__anon6	file:
tx	net.hh	/^    } tx;$/;"	m	struct:net::qp_stats	typeref:struct:net::qp_stats::__anon11
tx	xenfront.hh	/^union tx {$/;"	u	namespace:xen
tx_buf	dpdk.cc	/^        tx_buf(tx_buf_factory& fc) : _fc(fc) {$/;"	f	class:dpdk::dpdk_qp::tx_buf
tx_buf	dpdk.cc	/^    class tx_buf {$/;"	c	class:dpdk::dpdk_qp	file:
tx_buf_factory	dpdk.cc	/^        tx_buf_factory(uint8_t qid) {$/;"	f	class:dpdk::dpdk_qp::tx_buf_factory
tx_buf_factory	dpdk.cc	/^    class tx_buf_factory {$/;"	c	class:dpdk::dpdk_qp	file:
tx_csum_ip_offload	net.hh	/^    bool tx_csum_ip_offload = false;$/;"	m	struct:net::hw_features
tx_csum_l4_offload	net.hh	/^    bool tx_csum_l4_offload = false;$/;"	m	struct:net::hw_features
tx_time	tcp.hh	/^            clock_type::time_point tx_time;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::unacked_segment
tx_tso	net.hh	/^    bool tx_tso = false;$/;"	m	struct:net::hw_features
tx_ufo	net.hh	/^    bool tx_ufo = false;$/;"	m	struct:net::hw_features
txq	virtio.cc	/^    class txq {$/;"	c	class:virtio::qp	file:
txq	virtio.cc	/^qp::txq::txq(qp& dev, ring_config config)$/;"	f	class:virtio::qp::txq
txq_config	virtio.cc	/^ring_config qp::txq_config(size_t tx_ring_size) {$/;"	f	class:virtio::qp
type	dhcp.cc	/^        htype type = htype::ETHERNET;             \/\/ Hardware address type$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
type	dhcp.cc	/^        msg_type type = msg_type();$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::ip_info	file:
type	dhcp.cc	/^        msg_type type;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::type_option	file:
type	dhcp.cc	/^        opt_type type;$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::option_mark	file:
type	ip.hh	/^    msg_type type;$/;"	m	struct:net::icmp_hdr
type	tls.cc	/^    enum class type$/;"	c	class:seastar::tls::session	file:
type_option	dhcp.cc	/^        type_option(msg_type t) : option(opt_type::MESSAGE_TYPE), type(t) {}$/;"	f	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::type_option
type_option	dhcp.cc	/^    struct type_option : public option {$/;"	s	class:net::dhcp::impl::m_type::htype::opt_type::msg_type	file:
u	api.hh	/^    } u;$/;"	m	class:socket_address	typeref:union:socket_address::__anon2
udp	const.hh	/^    icmp = 1, tcp = 6, udp = 17, unused = 255$/;"	m	class:net::ip_protocol_num
udp_channel	api.hh	/^class udp_channel {$/;"	c	namespace:seastar::net
udp_channel	stack.cc	/^net::udp_channel::udp_channel()$/;"	f	class:net::udp_channel
udp_channel	stack.cc	/^net::udp_channel::udp_channel(std::unique_ptr<udp_channel_impl> impl) : _impl(std::move(impl))$/;"	f	class:net::udp_channel
udp_channel_impl	stack.hh	/^class udp_channel_impl {$/;"	c	namespace:net
udp_channel_state	udp.hh	/^    udp_channel_state(size_t queue_size) : _queue(queue_size) {}$/;"	f	struct:net::udp_channel_state
udp_channel_state	udp.hh	/^struct udp_channel_state {$/;"	s	namespace:net
udp_datagram	api.hh	/^    udp_datagram(std::unique_ptr<udp_datagram_impl>&& impl) : _impl(std::move(impl)) {};$/;"	f	class:seastar::net::final
udp_datagram_impl	api.hh	/^class udp_datagram_impl {$/;"	c	namespace:seastar::net
udp_hdr	udp.hh	/^struct udp_hdr {$/;"	s	namespace:net
udp_hdr_len	packet.hh	/^    uint8_t udp_hdr_len = 8;$/;"	m	struct:net::offload_info
udp_pseudo_header_checksum	ip.hh	/^    static void udp_pseudo_header_checksum(checksummer& csum, ipv4_address src, ipv4_address dst, uint16_t len) {$/;"	f	struct:net::ipv4_traits
unacked_segment	tcp.hh	/^        struct unacked_segment {$/;"	s	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
unacknowledged	tcp.hh	/^            tcp_seq unacknowledged;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
unregister	ip.hh	/^        void unregister() {$/;"	f	class:net::ipv4_udp::registration
unsent	tcp.hh	/^            std::deque<packet> unsent;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
unsent_len	tcp.hh	/^            uint32_t unsent_len = 0;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
unuse_internal_data	packet.hh	/^        void unuse_internal_data() {$/;"	f	struct:net::final::impl
unused	const.hh	/^    icmp = 1, tcp = 6, udp = 17, unused = 255$/;"	m	class:net::ip_protocol_num
update_copy_stats	net.hh	/^    void update_copy_stats(uint64_t nr_frags, uint64_t bytes) {$/;"	f	struct:net::qp_stats_good
update_cwnd	tcp.hh	/^void tcp<InetTraits>::tcb::update_cwnd(uint32_t acked_bytes) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
update_frags_stats	net.hh	/^    void update_frags_stats(uint64_t nfrags, uint64_t nbytes) {$/;"	f	struct:net::qp_stats_good
update_pkts_bunch	net.hh	/^    void update_pkts_bunch(uint64_t count) {$/;"	f	struct:net::qp_stats_good
update_rto	tcp.hh	/^void tcp<InetTraits>::tcb::update_rto(clock_type::time_point tx_time) {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
update_rx_count	virtio.cc	/^        void update_rx_count(uint64_t c) {$/;"	f	class:virtio::qp::rxq
urgent	tcp.hh	/^            tcp_seq urgent;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
urgent	tcp.hh	/^            tcp_seq urgent;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
urgent	tcp.hh	/^    packed<uint16_t> urgent;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
used	virtio.cc	/^    char* used;$/;"	m	struct:virtio::ring_config	file:
used	virtio.cc	/^    struct used {$/;"	s	class:virtio::vring	file:
used	virtio.cc	/^vring<BufferChain, Completion>::used::used(ring_config conf)$/;"	f	class:virtio::vring::used
used_elem	virtio.cc	/^    struct used_elem {$/;"	s	class:virtio::vring	file:
used_layout	virtio.cc	/^    struct used_layout {$/;"	s	class:virtio::vring	file:
user_queue_space	tcp.hh	/^            semaphore user_queue_space = {212992};$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
userspace	native-stack.cc	/^    userspace = 1,$/;"	m	class:net::xen_info	file:
using_internal_data	packet.hh	/^        bool using_internal_data() const {$/;"	f	struct:net::final::impl
vec_push	tls.cc	/^    ssize_t vec_push(const giovec_t * iov, int iovcnt) {$/;"	f	class:seastar::tls::session
vec_push_wrapper	tls.cc	/^    static ssize_t vec_push_wrapper(gnutls_transport_ptr_t ptr, const giovec_t * iov, int iovcnt) {$/;"	f	class:seastar::tls::session
ver	ip.hh	/^    uint8_t ver : 4;$/;"	m	struct:net::ip_hdr
verification_error	tls.hh	/^    class verification_error : public std::runtime_error {$/;"	c	class:seastar::tls::dh_params
verify	tls.cc	/^    void verify() {$/;"	f	class:seastar::tls::session
verify_wrapper	tls.cc	/^    static int verify_wrapper(gnutls_session_t gs) {$/;"	f	class:seastar::tls::session
virt_to_phys	virtio.cc	/^phys virt_to_phys(void* p) {$/;"	f	namespace:virtio
virtio	virtio.cc	/^namespace virtio {$/;"	n	file:
virtio_buffer	virtio.cc	/^static std::unique_ptr<char[], free_deleter> virtio_buffer(size_t size) {$/;"	f	namespace:virtio
vlan_tci	packet.hh	/^    std::experimental::optional<uint16_t> vlan_tci;$/;"	m	struct:net::offload_info
vmxnet3_max_xmit_segment_frags	dpdk.cc	/^static constexpr uint8_t vmxnet3_max_xmit_segment_frags = 16;$/;"	m	namespace:dpdk	file:
vring	virtio.cc	/^class vring {$/;"	c	namespace:virtio	file:
vring	virtio.cc	/^vring<BufferChain, Completion>::vring(ring_config conf, Completion complete)$/;"	f	class:virtio::vring
vring_storage_size	virtio.cc	/^size_t qp::vring_storage_size(size_t ring_size) {$/;"	f	class:virtio::qp
wait_for_all_data_acked	tcp.hh	/^future<> tcp<InetTraits>::tcb::wait_for_all_data_acked() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
wait_for_data	tcp.hh	/^        future<> wait_for_data() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
wait_for_data	tcp.hh	/^future<> tcp<InetTraits>::tcb::wait_for_data() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::tcb
wait_for_input	tls.cc	/^    future<> wait_for_input() {$/;"	f	class:seastar::tls::session
wait_for_output	tls.cc	/^    future<> wait_for_output() {$/;"	f	class:seastar::tls::session
wait_for_send_buffer	udp.hh	/^    future<> wait_for_send_buffer(size_t len) { return _user_queue_space.wait(len); }$/;"	f	struct:net::udp_channel_state
wake_notifier_wait	virtio.cc	/^        void wake_notifier_wait() {$/;"	f	class:virtio::qp::rxq
wake_notifier_wait	virtio.cc	/^        void wake_notifier_wait() {$/;"	f	class:virtio::qp::txq
wake_notifier_wait	virtio.cc	/^    void wake_notifier_wait() {$/;"	f	class:virtio::vring
wake_wait	virtio.cc	/^    virtual void wake_wait() {$/;"	f	class:virtio::notifier
win_scale	tcp.hh	/^    enum class option_kind: uint8_t { mss = 2, win_scale = 3, sack = 4, timestamps = 8,  nop = 1, eol = 0 };$/;"	m	class:net::tcp_state::tcp_option::option_kind
win_scale	tcp.hh	/^    enum class option_len:  uint8_t { mss = 4, win_scale = 3, sack = 2, timestamps = 10, nop = 1, eol = 1 };$/;"	m	class:net::tcp_state::tcp_option::option_kind::option_len
win_scale	tcp.hh	/^    struct win_scale {$/;"	s	class:net::tcp_state::tcp_option::option_kind::option_len
window	tcp.hh	/^            uint32_t window;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
window	tcp.hh	/^            uint32_t window;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
window	tcp.hh	/^    packed<uint16_t> window;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp_hdr
window_probe	tcp.hh	/^            bool window_probe = false;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
window_scale	tcp.hh	/^            uint8_t window_scale;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::receive
window_scale	tcp.hh	/^            uint8_t window_scale;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
wl1	tcp.hh	/^            tcp_seq wl1;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
wl2	tcp.hh	/^            tcp_seq wl2;$/;"	m	struct:net::tcp_state::tcp_option::option_kind::tcp::tcb::send
wmb	xenfront.cc	/^#define wmb(/;"	d	file:
wrap_client	tls.cc	/^future<::connected_socket> seastar::tls::wrap_client(::shared_ptr<certificate_credentials> cred, ::connected_socket&& s, sstring name) {$/;"	f	class:seastar::tls
wrap_server	tls.cc	/^future<::connected_socket> seastar::tls::wrap_server(::shared_ptr<server_credentials> cred, ::connected_socket&& s) {$/;"	f	class:seastar::tls
writeable	virtio.cc	/^            uint16_t writeable : 1;$/;"	m	struct:virtio::vring::desc::flags	file:
writeable	virtio.cc	/^    bool writeable;$/;"	m	struct:virtio::buffer	file:
x509_cert	tls.cc	/^seastar::tls::x509_cert::x509_cert(::shared_ptr<impl> impl)$/;"	f	class:seastar::tls::x509_cert
x509_cert	tls.cc	/^seastar::tls::x509_cert::x509_cert(const blob& b, x509_crt_format fmt)$/;"	f	class:seastar::tls::x509_cert
x509_cert	tls.hh	/^    class x509_cert {$/;"	c	class:seastar::tls::dh_params
x509_crl_key	tls.cc	/^static const sstring x509_crl_key = "x509_crl";$/;"	v	file:
x509_crt_format	tls.hh	/^    enum class x509_crt_format {$/;"	c	namespace:seastar::tls
x509_key_key	tls.cc	/^static const sstring x509_key_key = "x509_key";$/;"	v	file:
x509_trust_key	tls.cc	/^static const sstring x509_trust_key = "x509_trust";$/;"	v	file:
xen	xenfront.cc	/^namespace xen {$/;"	n	file:
xen	xenfront.hh	/^namespace xen {$/;"	n
xen_info	native-stack.cc	/^enum class xen_info {$/;"	c	namespace:net	file:
xenfront_device	xenfront.cc	/^    xenfront_device(boost::program_options::variables_map opts, bool userspace)$/;"	f	class:xen::xenfront_device
xenfront_device	xenfront.cc	/^class xenfront_device : public device {$/;"	c	namespace:xen	file:
xenfront_qp	xenfront.cc	/^class xenfront_qp : public net::qp {$/;"	c	namespace:xen	file:
xenfront_qp	xenfront.cc	/^xenfront_qp::xenfront_qp(xenfront_device* dev, boost::program_options::variables_map opts)$/;"	f	class:xen::xenfront_qp
xid	dhcp.cc	/^        packed<uint32_t> xid = 0;           \/\/ Client sets Transaction ID, a random number$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
yiaddr	dhcp.cc	/^        ipv4_address yiaddr;  \/\/ 'your' (client) IP address.$/;"	m	struct:net::dhcp::impl::m_type::htype::opt_type::msg_type::dhcp_header	file:
~abstract_credentials	tls.hh	/^        virtual ~abstract_credentials() {};$/;"	f	class:seastar::tls::dh_params::abstract_credentials
~arp_for_protocol	arp.cc	/^arp_for_protocol::~arp_for_protocol() {$/;"	f	class:net::arp_for_protocol
~certificate_credentials	tls.cc	/^seastar::tls::certificate_credentials::~certificate_credentials() {$/;"	f	class:seastar::tls::certificate_credentials
~connected_socket	stack.cc	/^connected_socket::~connected_socket()$/;"	f	class:connected_socket
~connected_socket_impl	stack.hh	/^    virtual ~connected_socket_impl() {}$/;"	f	class:net::connected_socket_impl
~connection	tcp.hh	/^tcp<InetTraits>::connection::~connection() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::connection
~device	net.hh	/^    virtual ~device() {};$/;"	f	class:net::device
~dh_params	tls.cc	/^seastar::tls::dh_params::~dh_params() {$/;"	f	class:seastar::tls::dh_params
~dhcp	dhcp.cc	/^net::dhcp::~dhcp()$/;"	f	class:net::dhcp::impl::m_type::htype::opt_type::net::dhcp	file:
~dpdk_device	dpdk.cc	/^    ~dpdk_device() {$/;"	f	class:dpdk::dpdk_device
~dpdk_qp	dpdk.cc	/^    virtual ~dpdk_qp() {}$/;"	f	class:dpdk::dpdk_qp
~gnutlsinit	tls.cc	/^    ~gnutlsinit() {$/;"	f	class:gnutlsinit
~impl	tls.cc	/^    ~impl() {$/;"	f	class:seastar::tls::certificate_credentials::impl
~impl	tls.cc	/^    ~impl() {$/;"	f	class:seastar::tls::dh_params::impl
~impl	tls.cc	/^    ~impl() {$/;"	f	class:seastar::tls::x509_cert::impl
~ip_packet_filter	ip.hh	/^    virtual ~ip_packet_filter() {};$/;"	f	struct:net::ip_packet_filter
~ip_protocol	ip.hh	/^    virtual ~ip_protocol() {}$/;"	f	class:net::ip_protocol
~ipv4_tcp	tcp.cc	/^ipv4_tcp::~ipv4_tcp() {$/;"	f	class:net::ipv4_tcp
~listener	tcp.hh	/^        ~listener() {$/;"	f	class:net::tcp_state::tcp_option::option_kind::tcp::listener
~native_channel	udp.cc	/^    ~native_channel()$/;"	f	class:net::ipv4_udp_impl::native_channel
~network_stack	api.hh	/^    virtual ~network_stack() {}$/;"	f	class:seastar::network_stack
~notifier	virtio.cc	/^    virtual ~notifier() {$/;"	f	class:virtio::notifier
~posix_udp_channel	posix-stack.cc	/^    virtual ~posix_udp_channel() { if (!_closed) close(); };$/;"	f	class:net::posix_udp_channel
~qp	net.cc	/^qp::~qp() {$/;"	f	class:net::qp
~server_socket	stack.cc	/^server_socket::~server_socket() {$/;"	f	class:server_socket
~server_socket_impl	stack.hh	/^    virtual ~server_socket_impl() {}$/;"	f	class:net::server_socket_impl
~session	tls.cc	/^    ~session() {$/;"	f	class:seastar::tls::session
~socket	stack.cc	/^seastar::socket::~socket()$/;"	f	class:seastar::socket
~socket_impl	stack.hh	/^    virtual ~socket_impl() {}$/;"	f	class:net::socket_impl
~udp_channel	stack.cc	/^net::udp_channel::~udp_channel()$/;"	f	class:net::udp_channel
~udp_channel_impl	stack.hh	/^    virtual ~udp_channel_impl() {};$/;"	f	class:net::udp_channel_impl
~udp_datagram_impl	api.hh	/^    virtual ~udp_datagram_impl() {};$/;"	f	class:seastar::net::udp_datagram_impl
~xenfront_qp	xenfront.cc	/^xenfront_qp::~xenfront_qp() {$/;"	f	class:xen::xenfront_qp
